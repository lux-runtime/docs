{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Lux Runtime","text":"<p>Standalone Luau Runtime</p> Discord \u00b7 GitHub \u00b7 LPM <p>Lux is a standalone runtime for Luau scripts built in Rust. Execute Luau outside of Roblox with a complete standard library.</p>"},{"location":"#quick-install-windows","title":"Quick Install (Windows)","text":"<pre><code>irm https://raw.githubusercontent.com/lux-runtime/lux/main/install.ps1 | iex\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Complete Standard Library - Filesystem, process, task scheduling, serialization, regex, datetime, stdio</li> <li>Foreign Function Interface - Call native C libraries using LuaJIT-style FFI</li> <li>Async Support - Cooperative multitasking with <code>task.spawn</code>, <code>task.wait</code>, <code>task.delay</code>, <code>task.defer</code></li> <li>Package Manager - LPM for dependency management and project initialization</li> <li>Cross-Platform - Windows, Linux, macOS</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal serde = require(\"@lux/serde\")\n\nlocal content = fs.readFile(\"config.json\")\nlocal config = serde.decode(\"json\", content)\nprint(config.name)\n</code></pre>"},{"location":"#standard-library","title":"Standard Library","text":"Module Description fs Filesystem operations process Process execution and environment task Async task scheduling serde Serialization and hashing regex Regular expressions datetime Date and time stdio Console I/O and prompts luau Bytecode compilation ffi Foreign Function Interface"},{"location":"#getting-started","title":"Getting Started","text":"<p>See the Installation Guide or use the quick install script above.</p>"},{"location":"#repositories","title":"Repositories","text":"Repository Description lux-runtime/lux Lux Runtime lux-runtime/lpm Package Manager lux-runtime/docs Documentation"},{"location":"#community","title":"Community","text":"<ul> <li>Discord Server</li> <li>GitHub</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Lux Runtime.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Globals: Comprehensive documentation for all global variables and types (<code>_G</code>, <code>Vector3</code>, <code>Color3</code>, etc.).</li> <li>Signal: New <code>signal</code> module for high-performance events.</li> <li>FFI: Added <code>alignof</code>, <code>offsetof</code>, <code>addressof</code>, <code>metatype</code>, <code>batch</code>, and <code>batch2</code> functions.</li> <li>Guide: New \"High Performance\" section in FFI guide covering batch processing.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>RunService: Removed the <code>runservice</code> module completely.</li> <li>DateTime: Updated documentation to match implementation (removed RFC methods, standardized on ISO/Unix).</li> <li>Copyright: Updated project copyright to 2025.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Documentation discrepancies in FFI and DateTime modules.</li> </ul>"},{"location":"changelog/#010-initial-release","title":"0.1.0 - Initial Release","text":""},{"location":"changelog/#standard-library","title":"Standard Library","text":"<ul> <li> <p>fs - Filesystem operations</p> <ul> <li><code>readFile</code>, <code>writeFile</code> - Read/write file contents</li> <li><code>readDir</code>, <code>writeDir</code> - List/create directories</li> <li><code>removeFile</code>, <code>removeDir</code> - Delete files/directories</li> <li><code>isFile</code>, <code>isDir</code> - Check path types</li> <li><code>move</code>, <code>copy</code> - Move/copy with overwrite option</li> <li><code>metadata</code> - Get file info (size, timestamps, permissions)</li> </ul> </li> <li> <p>process - Process management</p> <ul> <li><code>process.os</code>, <code>process.arch</code>, <code>process.endianness</code> - System info</li> <li><code>process.args</code>, <code>process.cwd</code>, <code>process.env</code> - Environment</li> <li><code>process.exit(code)</code> - Exit with code</li> <li><code>process.exec(cmd, args, opts)</code> - Execute and wait</li> <li><code>process.create(cmd, args, opts)</code> - Spawn background process</li> </ul> </li> <li> <p>task - Async scheduling</p> <ul> <li><code>task.spawn(fn)</code> - Run concurrently</li> <li><code>task.defer(fn)</code> - Run after current function</li> <li><code>task.delay(secs, fn)</code> - Run after delay</li> <li><code>task.wait(secs)</code> - Pause execution</li> <li><code>task.cancel(thread)</code> - Cancel scheduled task</li> </ul> </li> <li> <p>serde - Serialization</p> <ul> <li><code>encode/decode</code> - JSON, TOML, YAML, JSONC</li> <li><code>compress/decompress</code> - gzip, brotli, lz4, zlib, zstd</li> <li><code>hash</code> - MD5, SHA1/224/256/384/512, SHA3, BLAKE3</li> <li><code>hmac</code> - Keyed hashing</li> </ul> </li> <li> <p>regex - Regular expressions</p> <ul> <li><code>regex.new(pattern)</code> - Create pattern</li> <li><code>isMatch</code>, <code>find</code>, <code>captures</code> - Matching</li> <li><code>split</code>, <code>replace</code>, <code>replaceAll</code> - Text manipulation</li> <li>Named capture groups with <code>format()</code></li> </ul> </li> <li> <p>datetime - Date and time</p> <ul> <li><code>datetime.now()</code> - Current time</li> <li><code>fromUnixTimestamp</code>, <code>fromLocalTime</code>, <code>fromUniversalTime</code></li> <li><code>fromRfc3339</code>, <code>fromRfc2822</code> - Parse strings</li> <li><code>toRfc3339</code>, <code>toRfc2822</code> - Format strings</li> <li><code>formatLocalTime</code>, <code>formatUniversalTime</code> - Custom formats</li> <li>Locale support (en, de, es, fr, it, ja, pl, pt, pt-br, tr)</li> </ul> </li> <li> <p>stdio - Console I/O</p> <ul> <li><code>write</code>, <code>ewrite</code> - Output to stdout/stderr</li> <li><code>readLine</code>, <code>readToEnd</code> - Read from stdin</li> <li><code>format</code> - Pretty-print values</li> <li><code>color</code>, <code>style</code> - ANSI formatting</li> <li><code>prompt</code> - Interactive prompts (text, confirm, select, multiselect)</li> </ul> </li> <li> <p>luau - Bytecode compilation</p> <ul> <li><code>luau.compile(source, opts)</code> - Compile to bytecode</li> <li><code>luau.load(source, opts)</code> - Load and execute</li> <li>Custom environments for sandboxing</li> </ul> </li> <li> <p>ffi - Foreign Function Interface</p> <ul> <li><code>ffi.cdef</code> - Define C types (structs, enums, unions, functions)</li> <li><code>ffi.load</code> - Load dynamic libraries</li> <li><code>ffi.new</code> - Allocate C data (including VLAs)</li> <li><code>ffi.sizeof</code>, <code>ffi.string</code>, <code>ffi.cast</code></li> <li><code>ffi.callback</code> - Create C-callable callbacks</li> <li><code>ffi.copy</code>, <code>ffi.fill</code> - Memory operations</li> <li><code>ffi.C</code> - System C library access</li> </ul> </li> </ul>"},{"location":"changelog/#runtime","title":"Runtime","text":"<ul> <li>Cross-platform support (Windows, Linux, macOS)</li> <li><code>@lux/*</code> require aliases for standard library</li> <li>Cooperative multitasking with coroutines</li> </ul>"},{"location":"changelog/#package-manager-lpm","title":"Package Manager (LPM)","text":"<ul> <li><code>lpm init</code> - Interactive project initialization</li> <li><code>lpm install</code> - Install dependencies</li> <li><code>lpm add/remove</code> - Manage dependencies</li> <li><code>lpm run</code> - Run scripts from lux.toml</li> <li>Automatic type definition generation in <code>.lux/types/</code></li> <li><code>.luaurc</code> configuration for Luau LSP</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Complete API reference for all modules</li> <li>Guides for each major feature</li> <li>MkDocs Material theme with search</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":""},{"location":"cli/#lux","title":"lux","text":"<p>The Lux runtime executable.</p>"},{"location":"cli/#run","title":"run","text":"<p>Execute a Luau script.</p> <pre><code>lux run &lt;script&gt; [args...]\n</code></pre> <p>Examples: <pre><code>lux run main.luau\nlux run src/app.luau\nlux run script.luau arg1 arg2\n</code></pre></p> <p>Arguments after the script are available via <code>process.args</code>.</p>"},{"location":"cli/#check","title":"check","text":"<p>Check for syntax errors without running.</p> <pre><code>lux check &lt;script&gt;\n</code></pre> <p>Example: <pre><code>lux check main.luau\n</code></pre></p>"},{"location":"cli/#-eval-e","title":"--eval, -e","text":"<p>Evaluate inline Luau code.</p> <pre><code>lux -e \"print('Hello!')\"\nlux -e \"local fs = require('@lux/fs'); print(fs.readDir('.'))\"\n</code></pre>"},{"location":"cli/#-version","title":"--version","text":"<p>Print version information.</p> <pre><code>lux --version\n</code></pre>"},{"location":"cli/#-help","title":"--help","text":"<p>Print help.</p> <pre><code>lux --help\n</code></pre>"},{"location":"cli/#lpm","title":"lpm","text":"<p>The Lux Package Manager.</p>"},{"location":"cli/#init","title":"init","text":"<p>Initialize a new project interactively.</p> <pre><code>lpm init\n</code></pre> <p>Prompts for: - Package name - Version - Description - Author - License (MIT, Apache-2.0, MPL-2.0, etc.) - Repository URL - Entry point</p> <p>Creates: - <code>lux.toml</code> - Project manifest - <code>src/main.luau</code> - Entry point - <code>.lux/types/</code> - Type definitions - <code>.luaurc</code> - Language config - <code>.vscode/settings.json</code> - Editor config - <code>.gitignore</code></p>"},{"location":"cli/#install","title":"install","text":"<p>Install all dependencies from <code>lux.toml</code>.</p> <pre><code>lpm install\n</code></pre>"},{"location":"cli/#add","title":"add","text":"<p>Add a dependency.</p> <pre><code>lpm add &lt;package&gt;\nlpm add &lt;package&gt;@&lt;version&gt;\n</code></pre> <p>Examples: <pre><code>lpm add json-utils\nlpm add http-client@1.2.0\n</code></pre></p>"},{"location":"cli/#remove","title":"remove","text":"<p>Remove a dependency.</p> <pre><code>lpm remove &lt;package&gt;\n</code></pre>"},{"location":"cli/#run_1","title":"run","text":"<p>Run a script defined in <code>lux.toml</code>.</p> <pre><code>lpm run &lt;script&gt;\n</code></pre> <p>Example: <pre><code># lux.toml:\n# [scripts]\n# dev = \"lux src/main.luau\"\n# test = \"lux tests/init.luau\"\n\nlpm run dev\nlpm run test\n</code></pre></p>"},{"location":"cli/#update","title":"update","text":"<p>Update all dependencies to latest compatible versions.</p> <pre><code>lpm update\n</code></pre>"},{"location":"cli/#-version_1","title":"--version","text":"<p>Print LPM version.</p> <pre><code>lpm --version\n</code></pre>"},{"location":"cli/#-help_1","title":"--help","text":"<p>Print help.</p> <pre><code>lpm --help\n</code></pre>"},{"location":"cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>LUX_PATH</code> Additional module search paths"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Runtime error 2 Syntax/parse error"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#quick-install-windows","title":"Quick Install (Windows)","text":"<p>Run in PowerShell:</p> <pre><code>irm https://raw.githubusercontent.com/lux-runtime/lux/main/install.ps1 | iex\n</code></pre> <p>This downloads and installs: - lux - The runtime - lpm - Package manager</p>"},{"location":"getting-started/#manual-installation","title":"Manual Installation","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Rust 1.70 or later</li> <li>Git</li> </ul>"},{"location":"getting-started/#build-lux-runtime","title":"Build Lux Runtime","text":"<pre><code>git clone https://github.com/lux-runtime/lux\ncd lux/lux-runtime\ncargo build --release\n</code></pre> <p>Binary at <code>target/release/lux.exe</code> (Windows) or <code>target/release/lux</code> (Linux/macOS).</p>"},{"location":"getting-started/#build-lpm-package-manager","title":"Build LPM (Package Manager)","text":"<pre><code>git clone https://github.com/lux-runtime/lpm\ncd lpm\ncargo build --release\n</code></pre> <p>Binary at <code>target/release/lpm.exe</code> (Windows) or <code>target/release/lpm</code> (Linux/macOS).</p>"},{"location":"getting-started/#adding-to-path","title":"Adding to PATH","text":"Windows (PowerShell)Linux/macOS <pre><code># Create installation directory\nNew-Item -ItemType Directory -Path \"$env:USERPROFILE\\.lux\\bin\" -Force\n\n# Copy binaries\nCopy-Item \"lux-runtime\\target\\release\\lux.exe\" -Destination \"$env:USERPROFILE\\.lux\\bin\\\"\nCopy-Item \"lpm\\target\\release\\lpm.exe\" -Destination \"$env:USERPROFILE\\.lux\\bin\\\"\n\n# Add to PATH (requires terminal restart)\n$currentPath = [Environment]::GetEnvironmentVariable(\"Path\", \"User\")\n[Environment]::SetEnvironmentVariable(\"Path\", \"$currentPath;$env:USERPROFILE\\.lux\\bin\", \"User\")\n</code></pre> <pre><code>mkdir -p ~/.local/bin\ncp lux-runtime/target/release/lux ~/.local/bin/\ncp lpm/target/release/lpm ~/.local/bin/\n\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code>lux --version\nlpm --version\n</code></pre>"},{"location":"getting-started/#create-your-first-project","title":"Create Your First Project","text":"<pre><code>lpm init\n</code></pre> <p>Follow the prompts, then:</p> <pre><code>lpm run dev\n</code></pre>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<p>After <code>lpm init</code>:</p> <pre><code>my-project/\n\u251c\u2500\u2500 .lux/\n\u2502   \u2514\u2500\u2500 types/          # Type definitions for IDE\n\u251c\u2500\u2500 .vscode/\n\u2502   \u2514\u2500\u2500 settings.json   # VS Code config\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main.luau       # Entry point\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .luaurc             # Luau language config\n\u2514\u2500\u2500 lux.toml            # Project manifest\n</code></pre>"},{"location":"getting-started/#ide-setup","title":"IDE Setup","text":""},{"location":"getting-started/#vs-code","title":"VS Code","text":"<ol> <li>Install Luau Language Server</li> <li><code>lpm init</code> auto-configures <code>.vscode/settings.json</code></li> <li>Autocomplete works for <code>require(\"@lux/...\")</code></li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Basic examples</li> <li>CLI Reference - All commands</li> <li>Package Manager - Manage dependencies</li> <li>API Reference - All modules</li> </ul>"},{"location":"lpm/","title":"LPM - Lux Package Manager","text":"<p>Package manager for Lux Runtime projects.</p> <p>Repository: github.com/lux-runtime/lpm</p>"},{"location":"lpm/#installation","title":"Installation","text":""},{"location":"lpm/#quick-install-windows","title":"Quick Install (Windows)","text":"<pre><code>irm https://raw.githubusercontent.com/lux-runtime/lux/main/install.ps1 | iex\n</code></pre>"},{"location":"lpm/#build-from-source","title":"Build from Source","text":"<pre><code>git clone https://github.com/lux-runtime/lpm\ncd lpm\ncargo build --release\n</code></pre>"},{"location":"lpm/#commands","title":"Commands","text":""},{"location":"lpm/#init","title":"init","text":"<p>Initialize a new project interactively.</p> <pre><code>lpm init\n</code></pre> <p>Prompts for:</p> <ul> <li>Package name</li> <li>Version</li> <li>Description</li> <li>Author</li> <li>License (MIT, Apache-2.0, MPL-2.0, etc.)</li> <li>Repository URL</li> <li>Entry point</li> </ul> <p>Creates:</p> <ul> <li><code>lux.toml</code> - Project manifest</li> <li><code>src/main.luau</code> - Entry point</li> <li><code>.lux/types/</code> - Type definitions for IDE support</li> <li><code>.luaurc</code> - Luau LSP configuration</li> <li><code>.vscode/settings.json</code> - VS Code settings</li> <li><code>.gitignore</code></li> </ul>"},{"location":"lpm/#install","title":"install","text":"<p>Install dependencies from <code>lux.toml</code>.</p> <pre><code>lpm install\n</code></pre>"},{"location":"lpm/#add","title":"add","text":"<p>Add a dependency.</p> <pre><code>lpm add package-name\nlpm add package-name@1.0.0\n</code></pre>"},{"location":"lpm/#remove","title":"remove","text":"<p>Remove a dependency.</p> <pre><code>lpm remove package-name\n</code></pre>"},{"location":"lpm/#run","title":"run","text":"<p>Run a script defined in <code>lux.toml</code>.</p> <pre><code>lpm run dev\nlpm run test\n</code></pre>"},{"location":"lpm/#update","title":"update","text":"<p>Update dependencies.</p> <pre><code>lpm update\n</code></pre>"},{"location":"lpm/#luxtoml","title":"lux.toml","text":"<p>Project manifest format:</p> <pre><code>[package]\nname = \"my-project\"\nversion = \"0.1.0\"\ndescription = \"My Lux project\"\nauthors = [\"Your Name &lt;email@example.com&gt;\"]\nlicense = \"MIT\"\nrepository = \"https://github.com/user/repo\"\nentry = \"src/main.luau\"\n\n[scripts]\ndev = \"lux src/main.luau\"\ntest = \"lux tests/init.luau\"\n\n[dependencies]\nsome-package = \"^1.0.0\"\n\n[dev-dependencies]\ntest-lib = \"^2.0.0\"\n</code></pre>"},{"location":"lpm/#type-definitions","title":"Type Definitions","text":"<p><code>lpm init</code> generates type definitions in <code>.lux/types/</code> for:</p> Module File fs <code>.lux/types/fs.d.luau</code> process <code>.lux/types/process.d.luau</code> task <code>.lux/types/task.d.luau</code> serde <code>.lux/types/serde.d.luau</code> regex <code>.lux/types/regex.d.luau</code> datetime <code>.lux/types/datetime.d.luau</code> stdio <code>.lux/types/stdio.d.luau</code> luau <code>.lux/types/luau.d.luau</code> ffi <code>.lux/types/ffi.d.luau</code> <p>This enables IDE autocomplete for <code>require(\"@lux/...\")</code>.</p>"},{"location":"lpm/#luaurc-configuration","title":".luaurc Configuration","text":"<p>Generated <code>.luaurc</code>:</p> <pre><code>{\n    \"languageMode\": \"strict\",\n    \"aliases\": {\n        \"pkg\": \".lux_modules/packages\",\n        \"lux\": \".lux/types\"\n    }\n}\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#hello-world","title":"Hello World","text":"<p>Create <code>hello.luau</code>:</p> <pre><code>print(\"Hello, Lux!\")\n</code></pre> <p>Run:</p> <pre><code>lux run hello.luau\n</code></pre>"},{"location":"quickstart/#importing-modules","title":"Importing Modules","text":"<p>All modules use the <code>@lux</code> prefix:</p> <pre><code>local fs = require(\"@lux/fs\")\nlocal process = require(\"@lux/process\")\nlocal task = require(\"@lux/task\")\nlocal serde = require(\"@lux/serde\")\nlocal regex = require(\"@lux/regex\")\nlocal datetime = require(\"@lux/datetime\")\nlocal stdio = require(\"@lux/stdio\")\nlocal luau = require(\"@lux/luau\")\nlocal ffi = require(\"@lux/ffi\")\n</code></pre>"},{"location":"quickstart/#essential-examples","title":"Essential Examples","text":""},{"location":"quickstart/#read-and-write-files","title":"Read and Write Files","text":"<pre><code>local fs = require(\"@lux/fs\")\n\n-- Write\nfs.writeFile(\"message.txt\", \"Hello, Lux!\")\n\n-- Read\nlocal content = fs.readFile(\"message.txt\")\nprint(content)  -- Hello, Lux!\n\n-- Check existence\nif fs.isFile(\"message.txt\") then\n    print(\"File exists!\")\nend\n\n-- Delete\nfs.removeFile(\"message.txt\")\n</code></pre>"},{"location":"quickstart/#work-with-json","title":"Work with JSON","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal serde = require(\"@lux/serde\")\n\n-- Create config\nlocal config = {\n    name = \"my-app\",\n    version = \"1.0.0\",\n    debug = true\n}\n\n-- Save as JSON\nfs.writeFile(\"config.json\", serde.encode(\"json\", config, true))\n\n-- Load from JSON\nlocal loaded = serde.decode(\"json\", fs.readFile(\"config.json\"))\nprint(loaded.name)  -- my-app\n</code></pre>"},{"location":"quickstart/#run-commands","title":"Run Commands","text":"<pre><code>local process = require(\"@lux/process\")\n\n-- Simple command\nlocal result = process.exec(\"echo\", { \"Hello from shell!\" })\nprint(result.stdout)\n\n-- Check success\nif result.ok then\n    print(\"Command succeeded\")\nelse\n    print(\"Command failed:\", result.code)\nend\n</code></pre>"},{"location":"quickstart/#async-tasks","title":"Async Tasks","text":"<pre><code>local task = require(\"@lux/task\")\n\n-- Wait\nprint(\"Starting...\")\nlocal elapsed = task.wait(1)\nprint(\"Waited\", elapsed, \"seconds\")\n\n-- Spawn concurrent task\ntask.spawn(function()\n    task.wait(0.5)\n    print(\"Task completed after 0.5s\")\nend)\n\nprint(\"Main continues immediately\")\ntask.wait(1)  -- Wait for spawned task\n</code></pre>"},{"location":"quickstart/#date-and-time","title":"Date and Time","text":"<pre><code>local datetime = require(\"@lux/datetime\")\n\nlocal now = datetime.now()\nprint(now:formatLocalTime(\"%Y-%m-%d %H:%M:%S\"))\nprint(now:toRfc3339())  -- 2024-12-25T12:30:45Z\n</code></pre>"},{"location":"quickstart/#regex-matching","title":"Regex Matching","text":"<pre><code>local regex = require(\"@lux/regex\")\n\nlocal pattern = regex.new(\"\\\\d+\")\nprint(pattern:isMatch(\"abc123\"))  -- true\n\nlocal match = pattern:find(\"Price: 42\")\nif match then\n    print(match.text)  -- 42\nend\n</code></pre>"},{"location":"quickstart/#user-prompts","title":"User Prompts","text":"<pre><code>local stdio = require(\"@lux/stdio\")\n\nlocal name = stdio.prompt(\"text\", \"Enter your name:\", \"Guest\")\nprint(\"Hello, \" .. name)\n\nlocal confirmed = stdio.prompt(\"confirm\", \"Continue?\", true)\nif confirmed then\n    print(\"Continuing...\")\nend\n</code></pre>"},{"location":"quickstart/#environment-info","title":"Environment Info","text":"<pre><code>local process = require(\"@lux/process\")\n\nprint(\"OS:\", process.os)        -- windows, linux, macos\nprint(\"Arch:\", process.arch)    -- x86_64, aarch64\nprint(\"CWD:\", process.cwd)\nprint(\"PATH:\", process.env.PATH)\n</code></pre>"},{"location":"quickstart/#hash-data","title":"Hash Data","text":"<pre><code>local serde = require(\"@lux/serde\")\n\nlocal hash = serde.hash(\"sha256\", \"Hello, World!\")\nprint(\"SHA256:\", hash)\n\nlocal signature = serde.hmac(\"sha256\", \"message\", \"secret\")\nprint(\"HMAC:\", signature)\n</code></pre>"},{"location":"quickstart/#compress-data","title":"Compress Data","text":"<pre><code>local serde = require(\"@lux/serde\")\n\nlocal original = string.rep(\"Hello! \", 1000)\nlocal compressed = serde.compress(\"gzip\", original)\nlocal decompressed = serde.decompress(\"gzip\", compressed)\n\nprint(\"Original:\", #original, \"bytes\")\nprint(\"Compressed:\", #compressed, \"bytes\")\nassert(decompressed == original)\n</code></pre>"},{"location":"quickstart/#complete-example-mini-cli-app","title":"Complete Example: Mini CLI App","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal serde = require(\"@lux/serde\")\nlocal process = require(\"@lux/process\")\nlocal stdio = require(\"@lux/stdio\")\nlocal datetime = require(\"@lux/datetime\")\n\n-- Colors\nlocal green = stdio.color(\"green\")\nlocal red = stdio.color(\"red\")\nlocal reset = stdio.color(\"reset\")\n\nlocal function log(msg)\n    local timestamp = datetime.now():formatLocalTime(\"%H:%M:%S\")\n    print(\"[\" .. timestamp .. \"] \" .. msg)\nend\n\nlog(\"Starting application...\")\n\n-- Load or create config\nlocal configPath = \"config.json\"\nlocal config\n\nif fs.isFile(configPath) then\n    config = serde.decode(\"json\", fs.readFile(configPath))\n    log(green .. \"\u2713 Loaded config\" .. reset)\nelse\n    config = {\n        name = \"my-app\",\n        version = \"1.0.0\",\n        created = datetime.now():toRfc3339()\n    }\n    fs.writeFile(configPath, serde.encode(\"json\", config, true))\n    log(green .. \"\u2713 Created default config\" .. reset)\nend\n\n-- Show info\nprint()\nprint(\"Application: \" .. config.name)\nprint(\"Version: \" .. config.version)\nprint(\"OS: \" .. process.os)\nprint()\n\n-- User interaction\nlocal action = stdio.prompt(\"select\", \"What would you like to do?\", {\n    \"Show files\",\n    \"Run command\",\n    \"Exit\"\n})\n\nif action == 1 then\n    log(\"Listing files...\")\n    for _, name in fs.readDir(\".\") do\n        local kind = fs.isDir(name) and \"\ud83d\udcc1\" or \"\ud83d\udcc4\"\n        print(\"  \" .. kind .. \" \" .. name)\n    end\nelseif action == 2 then\n    local cmd = stdio.prompt(\"text\", \"Enter command:\")\n    local result = process.exec(cmd, nil, { shell = true })\n    if result.ok then\n        print(result.stdout)\n    else\n        print(red .. \"Error: \" .. result.stderr .. reset)\n    end\nend\n\nlog(\"Done!\")\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Full documentation for all modules</li> <li>Guides - In-depth tutorials</li> <li>LPM - Package management</li> </ul>"},{"location":"api/base64/","title":"Base64","text":"<p>Fast Base64 encoding and decoding.</p> <pre><code>local base64 = require(\"@lux/base64\")\n</code></pre>"},{"location":"api/base64/#overview","title":"Overview","text":"<p>Base64 is a binary-to-text encoding that represents binary data using 64 printable ASCII characters. Common uses include:</p> <ul> <li>Embedding binary data in JSON/XML</li> <li>Data URLs for images</li> <li>API authentication tokens</li> <li>Email attachments (MIME)</li> </ul>"},{"location":"api/base64/#functions","title":"Functions","text":""},{"location":"api/base64/#base64encodedata","title":"<code>base64.encode(data)</code>","text":"<p>Encodes data to standard Base64.</p> <pre><code>local encoded = base64.encode(\"Hello World\")\nprint(encoded) -- \"SGVsbG8gV29ybGQ=\"\n</code></pre> Parameter Type Description <code>data</code> <code>string \\| buffer</code> The data to encode <p>Returns: <code>string</code> - Base64 encoded string</p>"},{"location":"api/base64/#base64decodeencoded","title":"<code>base64.decode(encoded)</code>","text":"<p>Decodes standard Base64 to a buffer.</p> <pre><code>local decoded = base64.decode(\"SGVsbG8gV29ybGQ=\")\nprint(buffer.tostring(decoded)) -- \"Hello World\"\n</code></pre> Parameter Type Description <code>encoded</code> <code>string</code> Base64 encoded string <p>Returns: <code>buffer</code> - Decoded binary data</p>"},{"location":"api/base64/#base64encodeurldata","title":"<code>base64.encodeUrl(data)</code>","text":"<p>Encodes data to URL-safe Base64 (uses <code>-</code> and <code>_</code> instead of <code>+</code> and <code>/</code>).</p> <pre><code>local urlSafe = base64.encodeUrl(\"path/to/file?query=1\")\n-- No + or / characters, safe for URLs\n</code></pre>"},{"location":"api/base64/#base64decodeurlencoded","title":"<code>base64.decodeUrl(encoded)</code>","text":"<p>Decodes URL-safe Base64 to a buffer.</p> <pre><code>local decoded = base64.decodeUrl(urlSafe)\n</code></pre>"},{"location":"api/base64/#examples","title":"Examples","text":""},{"location":"api/base64/#binary-data","title":"Binary Data","text":"<pre><code>-- Create binary data\nlocal bin = buffer.create(4)\nbuffer.writeu32(bin, 0, 0xDEADBEEF)\n\n-- Encode and decode\nlocal encoded = base64.encode(bin)\nlocal decoded = base64.decode(encoded)\nprint(buffer.readu32(decoded, 0)) -- 0xDEADBEEF\n</code></pre>"},{"location":"api/base64/#data-urls","title":"Data URLs","text":"<pre><code>local imageData = fs.readFile(\"image.png\")\nlocal dataUrl = \"data:image/png;base64,\" .. base64.encode(imageData)\n</code></pre>"},{"location":"api/base64/#api-tokens","title":"API Tokens","text":"<pre><code>-- Encode credentials for Basic Auth\nlocal credentials = \"username:password\"\nlocal authHeader = \"Basic \" .. base64.encode(credentials)\n</code></pre>"},{"location":"api/datetime/","title":"datetime","text":"<p>Date and time operations.</p> <pre><code>local datetime = require(\"@lux/datetime\")\n</code></pre>"},{"location":"api/datetime/#constructors","title":"Constructors","text":""},{"location":"api/datetime/#now","title":"now","text":"<p>Returns current date and time.</p> <pre><code>datetime.now() -&gt; DateTime\n</code></pre>"},{"location":"api/datetime/#fromunixtimestamp","title":"fromUnixTimestamp","text":"<p>Creates DateTime from Unix timestamp (seconds). Fractional part represents milliseconds/nanoseconds.</p> <pre><code>datetime.fromUnixTimestamp(unixTimestamp: number) -&gt; DateTime\n</code></pre>"},{"location":"api/datetime/#fromuniversaltime","title":"fromUniversalTime","text":"<p>Creates DateTime from UTC time components.</p> <pre><code>datetime.fromUniversalTime(values: DateTimeValues) -&gt; DateTime\n</code></pre>"},{"location":"api/datetime/#fromlocaltime","title":"fromLocalTime","text":"<p>Creates DateTime from local time components.</p> <pre><code>datetime.fromLocalTime(values: DateTimeValues) -&gt; DateTime\n</code></pre>"},{"location":"api/datetime/#fromisodate","title":"fromIsoDate","text":"<p>Creates DateTime from ISO 8601 / RFC 3339 string.</p> <pre><code>datetime.fromIsoDate(isoDate: string) -&gt; DateTime\n</code></pre>"},{"location":"api/datetime/#datetime-properties","title":"DateTime Properties","text":"<pre><code>DateTime.unixTimestamp: number       -- Seconds since Unix epoch\nDateTime.unixTimestampMillis: number -- Milliseconds since Unix epoch\n</code></pre>"},{"location":"api/datetime/#datetime-methods","title":"DateTime Methods","text":""},{"location":"api/datetime/#touniversaltime","title":"toUniversalTime","text":"<p>Extracts UTC time components.</p> <pre><code>DateTime:toUniversalTime() -&gt; DateTimeValues\n</code></pre>"},{"location":"api/datetime/#tolocaltime","title":"toLocalTime","text":"<p>Extracts local time components.</p> <pre><code>DateTime:toLocalTime() -&gt; DateTimeValues\n</code></pre>"},{"location":"api/datetime/#formatuniversaltime","title":"formatUniversalTime","text":"<p>Formats as UTC using strftime pattern.</p> <pre><code>DateTime:formatUniversalTime(formatString: string?, locale: Locale?) -&gt; string\n</code></pre>"},{"location":"api/datetime/#formatlocaltime","title":"formatLocalTime","text":"<p>Formats as local time using strftime pattern.</p> <pre><code>DateTime:formatLocalTime(formatString: string?, locale: Locale?) -&gt; string\n</code></pre>"},{"location":"api/datetime/#toisodate","title":"toIsoDate","text":"<p>Returns ISO 8601 string.</p> <pre><code>DateTime:toIsoDate() -&gt; string\n</code></pre>"},{"location":"api/datetime/#types","title":"Types","text":"<p>DateTimeValues: <pre><code>type DateTimeValues = {\n    year: number,        -- 1400 -&gt; 9999\n    month: number,       -- 1 -&gt; 12\n    day: number,         -- 1 -&gt; 31\n    hour: number,        -- 0 -&gt; 23\n    minute: number,      -- 0 -&gt; 59\n    second: number,      -- 0 -&gt; 60 (60 = leap second)\n    millisecond: number?, -- 0 -&gt; 999 (optional for input, always present in output)\n}\n</code></pre></p> <p>Locale: <pre><code>type Locale = \"en\" | \"de\" | \"es\" | \"fr\" | \"it\" | \"ja\" | \"pl\" | \"pt-br\" | \"pt\" | \"tr\"\n</code></pre></p>"},{"location":"api/datetime/#format-tokens","title":"Format Tokens","text":"Token Example Description <code>%Y</code> 2024 Year (4 digits) <code>%m</code> 12 Month (01-12) <code>%d</code> 25 Day (01-31) <code>%H</code> 15 Hour (00-23) <code>%M</code> 30 Minute (00-59) <code>%S</code> 45 Second (00-59) <code>%A</code> Friday Weekday name <code>%B</code> December Month name <p>See chrono documentation for all tokens.</p>"},{"location":"api/datetime/#examples","title":"Examples","text":"<pre><code>local datetime = require(\"@lux/datetime\")\n\n-- Current time\nlocal now = datetime.now()\nprint(now.unixTimestamp)\n\n-- Formatting\nprint(now:toRfc3339())             -- 2024-12-25T15:30:00Z\nprint(now:toRfc2822())             -- Wed, 25 Dec 2024 15:30:00 +0000\nprint(now:formatLocalTime(\"%Y-%m-%d %H:%M:%S\"))\nprint(now:formatLocalTime(\"%A, %d %B %Y\", \"fr\")) -- French locale\n\n-- From timestamp\nlocal past = datetime.fromUnixTimestamp(0)\nprint(past:toRfc3339()) -- 1970-01-01T00:00:00Z\n\n-- From components\nlocal custom = datetime.fromLocalTime({\n    year = 2024, month = 12, day = 25,\n    hour = 12, minute = 0, second = 0\n})\n\n-- Extract components\nlocal parts = now:toLocalTime()\nprint(parts.year, parts.month, parts.day)\nprint(parts.hour, parts.minute, parts.second)\n\n-- Parse RFC 3339\nlocal parsed = datetime.fromRfc3339(\"2024-12-25T12:00:00Z\")\n</code></pre>"},{"location":"api/ffi/","title":"ffi","text":"<p>Foreign Function Interface for calling C libraries.</p> <pre><code>local ffi = require(\"@lux/ffi\")\n</code></pre>"},{"location":"api/ffi/#cdef","title":"cdef","text":"<p>Defines C types (structs, enums, unions, typedefs, functions).</p> <pre><code>ffi.cdef(declarations: string) -&gt; ()\n</code></pre> <p>Example: <pre><code>ffi.cdef[[\n    typedef struct Point {\n        int x;\n        int y;\n    } Point;\n\n    typedef enum Color {\n        RED = 0,\n        GREEN = 1,\n        BLUE = 2\n    } Color;\n]]\n</code></pre></p>"},{"location":"api/ffi/#load","title":"load","text":"<p>Loads a dynamic library.</p> <pre><code>ffi.load(path: string) -&gt; SmartLibrary\n</code></pre> <p>SmartLibrary allows calling functions defined via <code>cdef</code>: <pre><code>local lib = ffi.load(\"mylib.dll\")\nlocal result = lib.myFunction(args)\n</code></pre></p>"},{"location":"api/ffi/#new","title":"new","text":"<p>Creates a new C data object.</p> <pre><code>ffi.new(typeName: string) -&gt; CData\n</code></pre> <p>For variable-length arrays, use <code>[?]</code> syntax: <pre><code>local arr = ffi.new(\"int[?]\", 100)  -- 100 elements\n</code></pre></p> <p>CData properties:</p> <ul> <li><code>size</code> - Size in bytes</li> <li><code>[index]</code> - Array access (0-indexed)</li> <li><code>[fieldName]</code> - Struct field access</li> </ul>"},{"location":"api/ffi/#sizeof","title":"sizeof","text":"<p>Gets size of a type in bytes.</p> <pre><code>ffi.sizeof(typeName: string) -&gt; number\n</code></pre>"},{"location":"api/ffi/#string","title":"string","text":"<p>Converts a C string pointer to Lua string.</p> <pre><code>ffi.string(ptr: any, len: number?) -&gt; string?\n</code></pre>"},{"location":"api/ffi/#cast","title":"cast","text":"<p>Casts a value to a different type.</p> <pre><code>ffi.cast(typeName: string, value: any) -&gt; any\n</code></pre>"},{"location":"api/ffi/#callback","title":"callback","text":"<p>Creates a C-callable callback from a Lua function.</p> <pre><code>ffi.callback(signature: string, func: (...any) -&gt; any) -&gt; Callback\n</code></pre> <p>Example: <pre><code>local cb = ffi.callback(\"int(*)(int, int)\", function(a, b)\n    return a + b\nend)\n</code></pre></p>"},{"location":"api/ffi/#copy","title":"copy","text":"<p>Copies memory from source to destination.</p> <pre><code>ffi.copy(dst: CData, src: CData | string, len: number) -&gt; ()\n</code></pre>"},{"location":"api/ffi/#fill","title":"fill","text":"<p>Fills memory with a value.</p> <pre><code>ffi.fill(dst: CData, len: number, value: number?) -&gt; ()\n</code></pre> <p>Value defaults to 0.</p>"},{"location":"api/ffi/#istype","title":"istype","text":"<p>Checks if a CData is of a specific type.</p> <pre><code>ffi.istype(typeName: string, cdata: CData) -&gt; boolean\n</code></pre>"},{"location":"api/ffi/#alignof","title":"alignof","text":"<p>Gets the alignment of a type in bytes.</p> <pre><code>ffi.alignof(typeName: string) -&gt; number\n</code></pre>"},{"location":"api/ffi/#offsetof","title":"offsetof","text":"<p>Gets the offset of a field in a struct.</p> <pre><code>ffi.offsetof(typeName: string, fieldName: string) -&gt; number\n</code></pre>"},{"location":"api/ffi/#addressof","title":"addressof","text":"<p>Gets the address of a CData object.</p> <pre><code>ffi.addressof(cdata: CData) -&gt; CData\n</code></pre> <p>Returns a pointer (<code>void*</code>) to the data.</p>"},{"location":"api/ffi/#metatype","title":"metatype","text":"<p>Associates a metatable with a C type.</p> <pre><code>ffi.metatype(typeName: string, metatable: table) -&gt; CData\n</code></pre> <p>The metatable can define methods and metamethods (like <code>__tostring</code>, <code>__add</code>, <code>__index</code>) for the C type.</p>"},{"location":"api/ffi/#batch","title":"batch","text":"<p>Creates a batch allocator for high-performance zero-allocation loops.</p> <pre><code>ffi.batch(size: number) -&gt; Batch\n</code></pre> <p>Batch methods:</p> <ul> <li><code>add(cdata: CData) -&gt; CData</code> - Adds a CData to the batch (copy).</li> <li><code>commit() -&gt; ()</code> - Commits changes.</li> </ul>"},{"location":"api/ffi/#batch2","title":"batch2","text":"<p>Optimized batch allocator for fixed-size structs.</p> <pre><code>ffi.batch2&lt;T&gt;(typeName: string, count: number) -&gt; Batch2&lt;T&gt;\n</code></pre>"},{"location":"api/ffi/#gc","title":"gc","text":"<p>Sets a finalizer for a CData (called when garbage collected).</p> <pre><code>ffi.gc(cdata: CData, finalizer: (cdata: CData) -&gt; ()) -&gt; table\n</code></pre>"},{"location":"api/ffi/#c","title":"C","text":"<p>Access to the system C library (msvcrt on Windows, libc on Linux/macOS).</p> <pre><code>ffi.C\n</code></pre>"},{"location":"api/ffi/#supported-c-types","title":"Supported C Types","text":"Type Aliases Size <code>int</code> <code>int32_t</code>, <code>signed int</code> 4 bytes <code>unsigned int</code> <code>uint</code>, <code>uint32_t</code> 4 bytes <code>long</code> <code>long long</code>, <code>int64_t</code> 8 bytes <code>unsigned long</code> <code>uint64_t</code>, <code>ulong</code> 8 bytes <code>float</code> 4 bytes <code>double</code> 8 bytes <code>char</code> <code>signed char</code> 1 byte <code>unsigned char</code> <code>uchar</code> 1 byte <code>size_t</code> 8 bytes <code>void*</code> any pointer 8 bytes <code>char*</code> <code>const char*</code> 8 bytes"},{"location":"api/ffi/#examples","title":"Examples","text":""},{"location":"api/ffi/#struct-usage","title":"Struct Usage","text":"<pre><code>local ffi = require(\"@lux/ffi\")\n\nffi.cdef[[\n    typedef struct Point {\n        int x;\n        int y;\n    } Point;\n]]\n\nlocal point = ffi.new(\"Point\")\npoint.x = 100\npoint.y = 200\n\nprint(point.x, point.y)\nprint(\"Size:\", ffi.sizeof(\"Point\"))\n</code></pre>"},{"location":"api/ffi/#arrays","title":"Arrays","text":"<pre><code>ffi.cdef[[\n    typedef struct Buffer {\n        int size;\n        char data[256];\n    } Buffer;\n]]\n\n-- Fixed-size array in struct\nlocal buf = ffi.new(\"Buffer\")\nbuf.size = 256\n\n-- Variable-length array\nlocal arr = ffi.new(\"int[?]\", 1000)\nfor i = 0, 999 do\n    arr[i] = i * 2\nend\nprint(arr[500]) -- 1000\n</code></pre>"},{"location":"api/ffi/#enums","title":"Enums","text":"<pre><code>ffi.cdef[[\n    typedef enum {\n        MODE_READ = 1,\n        MODE_WRITE = 2,\n        MODE_APPEND = 4\n    } FileMode;\n]]\n\nprint(ffi.sizeof(\"FileMode\")) -- 4\n</code></pre>"},{"location":"api/ffi/#loading-libraries","title":"Loading Libraries","text":"<pre><code>local ffi = require(\"@lux/ffi\")\n\n-- Define function signature\nffi.cdef[[\n    int printf(const char* fmt, ...);\n]]\n\n-- Use system C library\nffi.C.printf(\"Hello from C!\\n\")\n</code></pre>"},{"location":"api/ffi/#callbacks","title":"Callbacks","text":"<pre><code>local ffi = require(\"@lux/ffi\")\n\n-- Create callback\nlocal myCb = ffi.callback(\"int(*)(int, int)\", function(a, b)\n    return a + b\nend)\n\n-- Can be passed to C functions expecting function pointers\n</code></pre>"},{"location":"api/fs/","title":"fs","text":"<p>Filesystem operations.</p> <pre><code>local fs = require(\"@lux/fs\")\n</code></pre>"},{"location":"api/fs/#functions","title":"Functions","text":""},{"location":"api/fs/#readfile","title":"readFile","text":"<p>Reads file contents as a string.</p> <pre><code>fs.readFile(path: string) -&gt; string\n</code></pre> <p>Example: <pre><code>local content = fs.readFile(\"config.json\")\nprint(content)\n</code></pre></p> <p>Errors:</p> <ul> <li>Path does not exist</li> <li>Insufficient permissions</li> <li>I/O error</li> </ul>"},{"location":"api/fs/#writefile","title":"writeFile","text":"<p>Writes content to a file. Creates if doesn't exist, overwrites if exists.</p> <pre><code>fs.writeFile(path: string, contents: buffer | string) -&gt; ()\n</code></pre> <p>Example: <pre><code>fs.writeFile(\"output.txt\", \"Hello, World!\")\n\n-- Binary data\nlocal data = buffer.create(10)\nfs.writeFile(\"binary.dat\", data)\n</code></pre></p> <p>Errors:</p> <ul> <li>Parent directory does not exist</li> <li>Insufficient permissions</li> <li>I/O error</li> </ul>"},{"location":"api/fs/#readdir","title":"readDir","text":"<p>Lists all entries in a directory.</p> <pre><code>fs.readDir(path: string) -&gt; { string }\n</code></pre> <p>Example: <pre><code>local entries = fs.readDir(\".\")\nfor _, name in entries do\n    print(name)\nend\n</code></pre></p>"},{"location":"api/fs/#writedir","title":"writeDir","text":"<p>Creates a directory and parent directories if missing.</p> <pre><code>fs.writeDir(path: string) -&gt; ()\n</code></pre> <p>Example: <pre><code>fs.writeDir(\"./output/logs/2024\")  -- Creates all parent dirs\n</code></pre></p>"},{"location":"api/fs/#removefile","title":"removeFile","text":"<p>Deletes a file.</p> <pre><code>fs.removeFile(path: string) -&gt; ()\n</code></pre> <p>Example: <pre><code>if fs.isFile(\"temp.txt\") then\n    fs.removeFile(\"temp.txt\")\nend\n</code></pre></p>"},{"location":"api/fs/#removedir","title":"removeDir","text":"<p>Deletes a directory and all its contents.</p> <pre><code>fs.removeDir(path: string) -&gt; ()\n</code></pre> <p>Warning</p> <p>This permanently deletes the directory and ALL contents recursively.</p> <p>Example: <pre><code>fs.removeDir(\"./temp\")  -- Deletes everything in temp/\n</code></pre></p>"},{"location":"api/fs/#isfile","title":"isFile","text":"<p>Checks if path is a file.</p> <pre><code>fs.isFile(path: string) -&gt; boolean\n</code></pre> <p>Example: <pre><code>if fs.isFile(\"config.json\") then\n    local config = fs.readFile(\"config.json\")\nend\n</code></pre></p>"},{"location":"api/fs/#isdir","title":"isDir","text":"<p>Checks if path is a directory.</p> <pre><code>fs.isDir(path: string) -&gt; boolean\n</code></pre> <p>Example: <pre><code>if not fs.isDir(\"./output\") then\n    fs.writeDir(\"./output\")\nend\n</code></pre></p>"},{"location":"api/fs/#move","title":"move","text":"<p>Moves or renames a file or directory.</p> <pre><code>fs.move(from: string, to: string, overwriteOrOptions: (boolean | WriteOptions)?) -&gt; ()\n</code></pre> <p>WriteOptions: <pre><code>type WriteOptions = {\n    overwrite: boolean?,\n}\n</code></pre></p> <p>Example: <pre><code>-- Rename\nfs.move(\"old.txt\", \"new.txt\")\n\n-- Move to directory\nfs.move(\"file.txt\", \"./archive/file.txt\")\n\n-- Overwrite existing\nfs.move(\"source.txt\", \"dest.txt\", true)\nfs.move(\"source.txt\", \"dest.txt\", { overwrite = true })\n</code></pre></p>"},{"location":"api/fs/#copy","title":"copy","text":"<p>Copies a file or directory recursively.</p> <pre><code>fs.copy(from: string, to: string, overwriteOrOptions: (boolean | WriteOptions)?) -&gt; ()\n</code></pre> <p>Example: <pre><code>-- Copy file\nfs.copy(\"original.txt\", \"backup.txt\")\n\n-- Copy directory (recursive)\nfs.copy(\"./src\", \"./src_backup\")\n\n-- Overwrite\nfs.copy(\"source.txt\", \"dest.txt\", true)\n</code></pre></p>"},{"location":"api/fs/#metadata","title":"metadata","text":"<p>Gets metadata for a path.</p> <pre><code>fs.metadata(path: string) -&gt; Metadata\n</code></pre> <p>Metadata type: <pre><code>type Metadata = {\n    kind: \"file\" | \"dir\" | \"symlink\",\n    exists: boolean,\n    createdAt: DateTime,\n    modifiedAt: DateTime,\n    accessedAt: DateTime,\n    permissions: {\n        readOnly: boolean,\n    },\n}\n</code></pre></p> <p>Example: <pre><code>local meta = fs.metadata(\"file.txt\")\n\nif meta.exists then\n    print(\"Kind:\", meta.kind)\n    print(\"Size check via metadata not available, use readFile\")\n    print(\"Modified:\", meta.modifiedAt.unixTimestamp)\n    print(\"Read-only:\", meta.permissions.readOnly)\nend\n</code></pre></p>"},{"location":"api/fs/#complete-examples","title":"Complete Examples","text":""},{"location":"api/fs/#file-watcher-polling","title":"File Watcher (Polling)","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal task = require(\"@lux/task\")\n\nlocal function watchFile(path, callback)\n    local lastModified = 0\n\n    while true do\n        local meta = fs.metadata(path)\n        if meta.exists then\n            local modified = meta.modifiedAt.unixTimestamp\n            if modified &gt; lastModified then\n                lastModified = modified\n                callback(path)\n            end\n        end\n        task.wait(1)  -- Check every second\n    end\nend\n\ntask.spawn(function()\n    watchFile(\"config.json\", function(path)\n        print(\"File changed:\", path)\n    end)\nend)\n</code></pre>"},{"location":"api/fs/#directory-tree","title":"Directory Tree","text":"<pre><code>local fs = require(\"@lux/fs\")\n\nlocal function tree(path, indent)\n    indent = indent or \"\"\n    local entries = fs.readDir(path)\n\n    for _, name in entries do\n        local fullPath = path .. \"/\" .. name\n        local isDir = fs.isDir(fullPath)\n\n        print(indent .. (isDir and \"\ud83d\udcc1 \" or \"\ud83d\udcc4 \") .. name)\n\n        if isDir then\n            tree(fullPath, indent .. \"  \")\n        end\n    end\nend\n\ntree(\"./src\")\n</code></pre>"},{"location":"api/fs/#safe-write-atomic","title":"Safe Write (Atomic)","text":"<pre><code>local fs = require(\"@lux/fs\")\n\nlocal function safeWrite(path, content)\n    local tempPath = path .. \".tmp\"\n    local backupPath = path .. \".bak\"\n\n    -- Write to temp file\n    fs.writeFile(tempPath, content)\n\n    -- Backup existing\n    if fs.isFile(path) then\n        fs.copy(path, backupPath, true)\n    end\n\n    -- Replace original\n    fs.move(tempPath, path, true)\n\n    -- Remove backup\n    if fs.isFile(backupPath) then\n        fs.removeFile(backupPath)\n    end\nend\n\nsafeWrite(\"important.txt\", \"Critical data\")\n</code></pre>"},{"location":"api/globals/","title":"Globals","text":"<p>Global variables and types available in the Lux runtime.</p>"},{"location":"api/globals/#core-globals","title":"Core Globals","text":""},{"location":"api/globals/#_g","title":"_G","text":"<p>A table shared across the entire environment, used for global data storage.</p> <pre><code>_G: { [any]: any }\n</code></pre>"},{"location":"api/globals/#_version","title":"_VERSION","text":"<p>The current Lux runtime version string.</p> <pre><code>_VERSION: string\n</code></pre>"},{"location":"api/globals/#print","title":"print","text":"<p>Prints values to stdout.</p> <pre><code>print(...: any) -&gt; ()\n</code></pre>"},{"location":"api/globals/#warn","title":"warn","text":"<p>Prints values to stderr (or structured warning output).</p> <pre><code>warn(...: any) -&gt; ()\n</code></pre>"},{"location":"api/globals/#require","title":"require","text":"<p>Loads a module.</p> <pre><code>require(path: string) -&gt; any\n</code></pre>"},{"location":"api/globals/#error","title":"error","text":"<p>Throws an error.</p> <pre><code>error(message: any, level: number?) -&gt; never\n</code></pre>"},{"location":"api/globals/#pcall-ypcall","title":"pcall / ypcall","text":"<p>Calls a function in protected mode (catches errors). <code>ypcall</code> is an alias for <code>pcall</code> in Luau.</p> <pre><code>pcall&lt;T..., R...&gt;(f: (T...) -&gt; R..., ...: T...) -&gt; (boolean, R...)\n</code></pre>"},{"location":"api/globals/#xpcall","title":"xpcall","text":"<p>Calls a function with a custom error handler.</p> <pre><code>xpcall&lt;T..., R...&gt;(f: (T...) -&gt; R..., err: (string) -&gt; any, ...: T...) -&gt; (boolean, R...)\n</code></pre>"},{"location":"api/globals/#type-typeof","title":"type / typeof","text":"<p>Returns the type of a value. <code>typeof</code> returns more granular types for Lux objects (e.g., \"Vector3\", \"DateTime\").</p> <pre><code>type(v: any) -&gt; string\ntypeof(v: any) -&gt; string\n</code></pre>"},{"location":"api/globals/#data-types","title":"Data Types","text":"<p>Lux includes data types compatible with Roblox API for easier portability.</p>"},{"location":"api/globals/#color3","title":"Color3","text":"<p>RGB color value (0-1 range).</p> <pre><code>type Color3 = { R: number, G: number, B: number }\n</code></pre> <p>Constructors:</p> Function Description <code>Color3.new(r, g, b)</code> Create from 0-1 values <code>Color3.fromRGB(r, g, b)</code> Create from 0-255 values <code>Color3.fromHSV(h, s, v)</code> Create from HSV <code>Color3.fromHex(hex)</code> Create from hex string <p>Methods:</p> Method Returns Description <code>:Lerp(goal, alpha)</code> Color3 Interpolate between colors <code>:ToHSV()</code> h, s, v Convert to HSV <code>:ToHex()</code> string Convert to hex (\"FF0000\")"},{"location":"api/globals/#vector2","title":"Vector2","text":"<p>2D vector for positions and directions.</p> <pre><code>type Vector2 = { X: number, Y: number, Magnitude: number, Unit: Vector2 }\n</code></pre> <p>Constructors:</p> <ul> <li><code>Vector2.new(x, y)</code> - Create from components</li> <li><code>Vector2.zero</code> - Constant (0, 0)</li> <li><code>Vector2.one</code> - Constant (1, 1)</li> </ul> <p>Methods:</p> Method Returns Description <code>:Lerp(goal, alpha)</code> Vector2 Linear interpolation <code>:Dot(other)</code> number Dot product <code>:Cross(other)</code> number 2D cross (z-component) <p>Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>-</code> (unary), <code>==</code></p>"},{"location":"api/globals/#vector3","title":"Vector3","text":"<p>3D vector for positions and directions.</p> <pre><code>type Vector3 = { X: number, Y: number, Z: number, Magnitude: number, Unit: Vector3 }\n</code></pre> <p>Constructors:</p> <ul> <li><code>Vector3.new(x, y, z)</code> - Create from components</li> <li><code>Vector3.zero</code> - Constant (0, 0, 0)</li> <li><code>Vector3.one</code> - Constant (1, 1, 1)</li> </ul> <p>Methods:</p> Method Returns Description <code>:Lerp(goal, alpha)</code> Vector3 Linear interpolation <code>:Dot(other)</code> number Dot product <code>:Cross(other)</code> Vector3 Cross product (perpendicular) <p>Operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>-</code> (unary), <code>==</code></p>"},{"location":"api/globals/#udim","title":"UDim","text":"<p>UI Dimension with scale and offset.</p> <pre><code>type UDim = { Scale: number, Offset: number }\n</code></pre> <p>Final size = <code>parentSize * Scale + Offset</code></p> <p>Constructors:</p> <ul> <li><code>UDim.new(scale, offset)</code></li> </ul>"},{"location":"api/globals/#udim2","title":"UDim2","text":"<p>2D UI Dimension for positions and sizes.</p> <pre><code>type UDim2 = { X: UDim, Y: UDim }\n</code></pre> <p>Constructors:</p> Function Description <code>UDim2.new(xScale, xOffset, yScale, yOffset)</code> Full constructor <code>UDim2.fromScale(x, y)</code> Scale only (offset = 0) <code>UDim2.fromOffset(x, y)</code> Offset only (scale = 0)"},{"location":"api/globals/#rect","title":"Rect","text":"<p>2D Rectangle.</p> <pre><code>type Rect = { Width: number, Height: number }\n</code></pre> <p>Constructors:</p> <ul> <li><code>Rect.new(minX, minY, maxX, maxY)</code></li> </ul>"},{"location":"api/globals/#numberrange","title":"NumberRange","text":"<p>A range between two numbers.</p> <pre><code>type NumberRange = { Min: number, Max: number }\n</code></pre> <p>Constructors:</p> <ul> <li><code>NumberRange.new(min, max)</code> - Coordinates auto-normalize</li> </ul>"},{"location":"api/globals/#enum","title":"Enum","text":"<p>Enumeration types for type-safe constants.</p>"},{"location":"api/globals/#enumkeycode","title":"Enum.KeyCode","text":"<p>Platform-specific keyboard key codes for FFI input handling.</p> <ul> <li>Windows: VK_* codes (for <code>GetAsyncKeyState</code>, etc.)</li> <li>Linux: evdev KEY_* codes</li> <li>macOS: Carbon kVK_* codes</li> </ul> <pre><code>-- FFI example\nffi.cdef(\"int16_t GetAsyncKeyState(int vKey);\")\nif ffi.C.GetAsyncKeyState(Enum.KeyCode.A) ~= 0 then\n    print(\"A key is pressed!\")\nend\n</code></pre> <p>Keys available: A-Z, Zero-Nine, F1-F12, Escape, Tab, Space, Return, Backspace, Delete, arrows (Up/Down/Left/Right), modifiers (LeftShift, RightShift, LeftControl, etc.), Numpad0-9, and more.</p>"},{"location":"api/globals/#enummousebutton","title":"Enum.MouseButton","text":"Name Value Description Left 0 Primary button Right 1 Secondary button Middle 2 Wheel click Button4 3 Extra button Button5 4 Extra button"},{"location":"api/globals/#enumeasingstyle","title":"Enum.EasingStyle","text":"Name Value Description Linear 0 Constant speed Quad 1 t\u00b2 Cubic 2 t\u00b3 Quart 3 t\u2074 Quint 4 t\u2075 Sine 5 Sinusoidal Expo 6 Exponential Circ 7 Circular Elastic 8 Spring overshoot Back 9 Slight overshoot Bounce 10 Bouncing"},{"location":"api/globals/#enumeasingdirection","title":"Enum.EasingDirection","text":"Name Value Description In 0 Slow start Out 1 Slow end InOut 2 Slow start and end"},{"location":"api/globals/#enumsortorder","title":"Enum.SortOrder","text":"Name Value LayoutOrder 0 Name 1"},{"location":"api/globals/#utilities","title":"Utilities","text":""},{"location":"api/globals/#task","title":"task","text":"<p>Reference to the <code>task</code> library for coroutine scheduling.</p>"},{"location":"api/luau/","title":"luau","text":"<p>Bytecode compilation and loading.</p> <pre><code>local luau = require(\"@lux/luau\")\n</code></pre>"},{"location":"api/luau/#compile","title":"compile","text":"<p>Compiles Luau source code to bytecode.</p> <pre><code>luau.compile(source: string, compileOptions: CompileOptions?) -&gt; string\n</code></pre> <p>CompileOptions: <pre><code>type CompileOptions = {\n    optimizationLevel: number?, -- 0, 1, or 2 (default: 1)\n    coverageLevel: number?,     -- 0, 1, or 2 (default: 0)\n    debugLevel: number?,        -- 0, 1, or 2 (default: 1)\n}\n</code></pre></p> <p>Errors: Throws if source is invalid Luau code.</p>"},{"location":"api/luau/#load","title":"load","text":"<p>Loads bytecode or source and returns a callable function.</p> <pre><code>luau.load(source: string, loadOptions: LoadOptions?) -&gt; (...any) -&gt; ...any\n</code></pre> <p>LoadOptions: <pre><code>type LoadOptions = {\n    debugName: string?,          -- Debug name (default: \"luau.load(...)\")\n    environment: { [string]: any }?, -- Custom environment\n    injectGlobals: boolean?,     -- Inject globals into custom environment (default: true)\n    codegenEnabled: boolean?,    -- Enable native codegen (default: false)\n}\n</code></pre></p> <p>Notes:</p> <ul> <li>Setting a custom environment disables codegen</li> <li>Source can be either Luau source code or compiled bytecode</li> </ul>"},{"location":"api/luau/#examples","title":"Examples","text":"<pre><code>local luau = require(\"@lux/luau\")\n\n-- Basic usage\nlocal bytecode = luau.compile(\"return 1 + 2\")\nlocal func = luau.load(bytecode)\nprint(func()) -- 3\n\n-- Direct from source (compile + load in one step)\nlocal func2 = luau.load(\"return 'Hello!'\")\nprint(func2()) -- Hello!\n\n-- With compile options\nlocal optimized = luau.compile(\"return 1 + 2\", {\n    optimizationLevel = 2,\n    debugLevel = 0,\n})\n\n-- With load options\nlocal func3 = luau.load(optimized, {\n    debugName = \"myFunction\",\n})\n\n-- Return a function\nlocal source = [[\n    local function greet(name)\n        return \"Hello, \" .. name .. \"!\"\n    end\n    return greet\n]]\nlocal greet = luau.load(source)()\nprint(greet(\"World\")) -- Hello, World!\n\n-- Custom environment (sandboxing)\nlocal sandboxed = luau.load(\"return x + y\", {\n    environment = { x = 10, y = 20 },\n    injectGlobals = false,\n})\nprint(sandboxed()) -- 30\n\n-- Custom environment with globals\nlocal withGlobals = luau.load(\"print(message); return 42\", {\n    environment = { message = \"Hello!\" },\n    injectGlobals = true, -- print is available\n})\nprint(withGlobals()) -- prints \"Hello!\", returns 42\n</code></pre>"},{"location":"api/noise/","title":"Noise","text":"<p>Procedural noise generation for terrain, textures, and procedural content.</p> <pre><code>local noise = require(\"@lux/noise\")\n</code></pre>"},{"location":"api/noise/#overview","title":"Overview","text":"<p>All noise functions return values in the range <code>[-1, 1]</code>. The library provides:</p> <ul> <li>Perlin noise: Classic gradient noise, smooth and natural-looking</li> <li>Simplex noise: Faster than Perlin with fewer directional artifacts  </li> <li>FBM (Fractal Brownian Motion): Layered noise for natural detail</li> </ul>"},{"location":"api/noise/#functions","title":"Functions","text":""},{"location":"api/noise/#noiseperlin2x-y","title":"<code>noise.perlin2(x, y)</code>","text":"<p>2D Perlin noise.</p> <pre><code>local value = noise.perlin2(x * 0.1, y * 0.1)\n-- value is between -1 and 1\n</code></pre>"},{"location":"api/noise/#noiseperlin3x-y-z","title":"<code>noise.perlin3(x, y, z)</code>","text":"<p>3D Perlin noise.</p> <pre><code>local density = noise.perlin3(x, y, z)\n</code></pre>"},{"location":"api/noise/#noisesimplex2x-y","title":"<code>noise.simplex2(x, y)</code>","text":"<p>2D Simplex noise (faster than Perlin, fewer artifacts).</p> <pre><code>local value = noise.simplex2(x, y)\n</code></pre>"},{"location":"api/noise/#noisesimplex3x-y-z","title":"<code>noise.simplex3(x, y, z)</code>","text":"<p>3D Simplex noise.</p> <pre><code>local value = noise.simplex3(x, y, z)\n</code></pre>"},{"location":"api/noise/#noisefbm2x-y-octaves-lacunarity-gain","title":"<code>noise.fbm2(x, y, octaves?, lacunarity?, gain?)</code>","text":"<p>2D Fractal Brownian Motion - layered noise for natural-looking patterns.</p> <pre><code>-- Basic usage with 4 octaves\nlocal terrain = noise.fbm2(x, y, 4)\n\n-- With custom parameters\nlocal detailed = noise.fbm2(x, y, 6, 2.0, 0.5)\n</code></pre> Parameter Type Default Description <code>x</code> <code>number</code> - X coordinate <code>y</code> <code>number</code> - Y coordinate <code>octaves</code> <code>number?</code> 6 Number of noise layers <code>lacunarity</code> <code>number?</code> 2.0 Frequency multiplier between octaves <code>gain</code> <code>number?</code> 0.5 Amplitude multiplier between octaves"},{"location":"api/noise/#noisefbm3x-y-z-octaves-lacunarity-gain","title":"<code>noise.fbm3(x, y, z, octaves?, lacunarity?, gain?)</code>","text":"<p>3D Fractal Brownian Motion.</p> <pre><code>local caveDensity = noise.fbm3(x, y, z, 4)\n</code></pre>"},{"location":"api/noise/#noisesetseedseed","title":"<code>noise.setSeed(seed)</code>","text":"<p>Sets the global noise seed for reproducibility.</p> <pre><code>noise.setSeed(12345)  -- Same seed = same noise pattern\n</code></pre>"},{"location":"api/noise/#examples","title":"Examples","text":""},{"location":"api/noise/#terrain-heightmap","title":"Terrain Heightmap","text":"<pre><code>local function generateTerrain(width, height)\n    noise.setSeed(os.time())\n    local heightmap = {}\n\n    for y = 1, height do\n        heightmap[y] = {}\n        for x = 1, width do\n            local nx = x / width\n            local ny = y / height\n            -- Use FBM for natural terrain\n            heightmap[y][x] = noise.fbm2(nx * 4, ny * 4, 6)\n        end\n    end\n\n    return heightmap\nend\n</code></pre>"},{"location":"api/noise/#cloud-texture","title":"Cloud Texture","text":"<pre><code>local function cloudDensity(x, y, time)\n    return noise.fbm2(x + time * 0.1, y, 4, 2.0, 0.6)\nend\n</code></pre>"},{"location":"api/overview/","title":"Standard Library","text":"<p>All modules are imported using <code>require(\"@lux/&lt;module&gt;\")</code>.</p>"},{"location":"api/overview/#modules","title":"Modules","text":"Module Description globals Global functions and types fs Filesystem operations process Process execution and environment task Async task scheduling signal Event system serde Serialization and hashing regex Regular expressions datetime Date and time stdio Console I/O and prompts luau Bytecode compilation ffi Foreign Function Interface"},{"location":"api/overview/#example","title":"Example","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal serde = require(\"@lux/serde\")\n\nlocal json = fs.readFile(\"config.json\")\nlocal config = serde.decode(\"json\", json)\nprint(config.name)\n</code></pre>"},{"location":"api/process/","title":"process","text":"<p>Process execution and environment.</p> <pre><code>local process = require(\"@lux/process\")\n</code></pre>"},{"location":"api/process/#properties","title":"Properties","text":""},{"location":"api/process/#os","title":"os","text":"<p>Current operating system.</p> <pre><code>process.os: \"linux\" | \"macos\" | \"windows\"\n</code></pre>"},{"location":"api/process/#arch","title":"arch","text":"<p>CPU architecture.</p> <pre><code>process.arch: \"x86_64\" | \"aarch64\"\n</code></pre>"},{"location":"api/process/#endianness","title":"endianness","text":"<p>Processor endianness.</p> <pre><code>process.endianness: \"big\" | \"little\"\n</code></pre>"},{"location":"api/process/#args","title":"args","text":"<p>Command-line arguments passed to the script.</p> <pre><code>process.args: { string }\n</code></pre>"},{"location":"api/process/#cwd","title":"cwd","text":"<p>Current working directory.</p> <pre><code>process.cwd: string\n</code></pre>"},{"location":"api/process/#env","title":"env","text":"<p>Environment variables. Supports read and write.</p> <pre><code>process.env: { [string]: string? }\n</code></pre>"},{"location":"api/process/#exit","title":"exit","text":"<p>Exits the process with a code.</p> <pre><code>process.exit(code: number?) -&gt; never\n</code></pre> <p>Exit code 0 = success, any other value = error.</p>"},{"location":"api/process/#exec","title":"exec","text":"<p>Executes a command and waits for it to complete.</p> <pre><code>process.exec(program: string, params: { string }?, options: ExecOptions?) -&gt; ExecResult\n</code></pre> <p>ExecOptions: <pre><code>type ExecOptions = {\n    cwd: string?,\n    env: { [string]: string }?,\n    shell: (boolean | string)?,\n    stdio: (ExecStdioKind | ExecStdioOptions)?,\n}\n\ntype ExecStdioKind = \"default\" | \"inherit\" | \"forward\" | \"none\"\n\ntype ExecStdioOptions = {\n    stdin: (buffer | string)?,\n    stdout: ExecStdioKind?,\n    stderr: ExecStdioKind?,\n}\n</code></pre></p> <p>ExecResult: <pre><code>type ExecResult = {\n    ok: boolean,\n    code: number,\n    stdout: string,\n    stderr: string,\n}\n</code></pre></p>"},{"location":"api/process/#create","title":"create","text":"<p>Spawns a child process in background and returns readers/writers for communication.</p> <pre><code>process.create(program: string, params: { string }?, options: CreateOptions?) -&gt; ChildProcess\n</code></pre> <p>CreateOptions: <pre><code>type CreateOptions = {\n    cwd: string?,\n    env: { [string]: string }?,\n    shell: (boolean | string)?,\n}\n</code></pre></p> <p>ChildProcess: <pre><code>type ChildProcess = {\n    stdin: ChildProcessWriter,\n    stdout: ChildProcessReader,\n    stderr: ChildProcessReader,\n    kill: (self: ChildProcess) -&gt; (),\n    status: (self: ChildProcess) -&gt; { ok: boolean, code: number },\n}\n</code></pre></p> <p>ChildProcessReader methods:</p> <ul> <li><code>read(chunkSize: number?) -&gt; string?</code> - Reads a chunk (yields if no data available)</li> <li><code>readToEnd() -&gt; string</code> - Reads all data (yields until process exits)</li> </ul> <p>ChildProcessWriter methods:</p> <ul> <li><code>write(data: buffer | string) -&gt; ()</code> - Writes data</li> <li><code>close() -&gt; ()</code> - Closes the stream</li> </ul>"},{"location":"api/process/#examples","title":"Examples","text":"<pre><code>local process = require(\"@lux/process\")\n\n-- Environment info\nprint(\"OS:\", process.os)\nprint(\"Arch:\", process.arch)\nprint(\"CWD:\", process.cwd)\n\n-- Environment variables\nprint(\"PATH:\", process.env.PATH)\nprocess.env.MY_VAR = \"hello\"\n\n-- Execute command\nlocal result = process.exec(\"echo\", { \"Hello\" })\nif result.ok then\n    print(result.stdout)\nelse\n    print(\"Error:\", result.stderr)\nend\n\n-- Execute with shell\nlocal result2 = process.exec(\"echo Hello &amp;&amp; echo World\", nil, { shell = true })\nprint(result2.stdout)\n\n-- Spawn background process\nlocal child = process.create(\"cat\")\nchild.stdin:write(\"Hello from Lux!\")\nchild.stdin:close()\nlocal output = child.stdout:readToEnd()\nprint(output)\n</code></pre>"},{"location":"api/regex/","title":"regex","text":"<p>Regular expressions.</p> <pre><code>local regex = require(\"@lux/regex\")\n</code></pre>"},{"location":"api/regex/#new","title":"new","text":"<p>Creates a new Regex from a pattern string.</p> <pre><code>regex.new(pattern: string) -&gt; Regex\n</code></pre> <p>Errors: Throws if the pattern is invalid.</p>"},{"location":"api/regex/#regex-methods","title":"Regex Methods","text":""},{"location":"api/regex/#ismatch","title":"isMatch","text":"<p>Checks if the pattern matches anywhere in the text.</p> <pre><code>Regex:isMatch(text: string) -&gt; boolean\n</code></pre>"},{"location":"api/regex/#find","title":"find","text":"<p>Finds the first match.</p> <pre><code>Regex:find(text: string) -&gt; RegexMatch?\n</code></pre> <p>RegexMatch: <pre><code>type RegexMatch = {\n    start: number,   -- Start index (1-based)\n    finish: number,  -- End index (1-based)\n    text: string,    -- Matched text\n    len: number,     -- Length of match\n}\n</code></pre></p>"},{"location":"api/regex/#captures","title":"captures","text":"<p>Gets all capture groups.</p> <pre><code>Regex:captures(text: string) -&gt; RegexCaptures?\n</code></pre> <p>RegexCaptures methods:</p> <ul> <li><code>get(index: number) -&gt; RegexMatch?</code> - Get match by index (0 = full match)</li> <li><code>group(name: string) -&gt; RegexMatch?</code> - Get match by named group</li> <li><code>format(formatString: string) -&gt; string</code> - Format captures</li> </ul>"},{"location":"api/regex/#split","title":"split","text":"<p>Splits text by the pattern.</p> <pre><code>Regex:split(text: string) -&gt; { string }\n</code></pre>"},{"location":"api/regex/#replace","title":"replace","text":"<p>Replaces the first match.</p> <pre><code>Regex:replace(haystack: string, replacer: string) -&gt; string\n</code></pre>"},{"location":"api/regex/#replaceall","title":"replaceAll","text":"<p>Replaces all matches.</p> <pre><code>Regex:replaceAll(haystack: string, replacer: string) -&gt; string\n</code></pre>"},{"location":"api/regex/#examples","title":"Examples","text":"<pre><code>local regex = require(\"@lux/regex\")\n\n-- Basic matching\nlocal pattern = regex.new(\"\\\\d+\")\nprint(pattern:isMatch(\"abc123\")) -- true\nprint(pattern:isMatch(\"abc\"))    -- false\n\n-- Find match\nlocal match = pattern:find(\"Price: 42\")\nif match then\n    print(match.text)  -- 42\n    print(match.start) -- 8\nend\n\n-- Split\nlocal parts = regex.new(\",\\\\s*\"):split(\"a, b, c\")\nfor _, p in parts do print(p) end -- a, b, c\n\n-- Replace\nprint(regex.new(\"cat\"):replace(\"cat dog cat\", \"bird\"))    -- bird dog cat\nprint(regex.new(\"cat\"):replaceAll(\"cat dog cat\", \"bird\")) -- bird dog bird\n\n-- Named capture groups\nlocal datePattern = regex.new(\"(?&lt;day&gt;\\\\d{2})-(?&lt;month&gt;\\\\d{2})-(?&lt;year&gt;\\\\d{4})\")\nlocal caps = datePattern:captures(\"Date: 25-12-2024\")\nif caps then\n    print(caps:get(0).text)       -- 25-12-2024 (full match)\n    print(caps:group(\"day\").text)  -- 25\n    print(caps:group(\"month\").text) -- 12\n    print(caps:group(\"year\").text)  -- 2024\n    print(caps:format(\"$year/$month/$day\")) -- 2024/12/25\nend\n</code></pre>"},{"location":"api/serde/","title":"serde","text":"<p>Serialization, deserialization, compression, and hashing.</p> <pre><code>local serde = require(\"@lux/serde\")\n</code></pre>"},{"location":"api/serde/#encode","title":"encode","text":"<p>Serializes a Lua value to a string.</p> <pre><code>serde.encode(format: EncodeDecodeFormat, value: any, pretty: boolean?) -&gt; string\n</code></pre> <p>Supported formats:</p> Format Description <code>\"json\"</code> JSON <code>\"yaml\"</code> YAML <code>\"toml\"</code> TOML <p>The <code>pretty</code> parameter enables human-readable output with newlines and indentation (JSON and TOML only).</p>"},{"location":"api/serde/#decode","title":"decode","text":"<p>Deserializes a string to a Lua value.</p> <pre><code>serde.decode(format: EncodeDecodeFormat, encoded: buffer | string) -&gt; any\n</code></pre> <p>Supported formats:</p> Format Description <code>\"json\"</code> JSON <code>\"jsonc\"</code> JSON with comments <code>\"yaml\"</code> YAML <code>\"toml\"</code> TOML"},{"location":"api/serde/#compress","title":"compress","text":"<p>Compresses data.</p> <pre><code>serde.compress(format: CompressDecompressFormat, s: buffer | string, level: number?) -&gt; string\n</code></pre> <p>Supported formats:</p> Format Description <code>\"brotli\"</code> Brotli compression <code>\"gzip\"</code> Gzip compression <code>\"lz4\"</code> LZ4 compression <code>\"zlib\"</code> Zlib compression <code>\"zstd\"</code> Zstandard compression <p>The <code>level</code> parameter controls compression level (clamped to format limits).</p>"},{"location":"api/serde/#decompress","title":"decompress","text":"<p>Decompresses data.</p> <pre><code>serde.decompress(format: CompressDecompressFormat, s: buffer | string) -&gt; string\n</code></pre>"},{"location":"api/serde/#hash","title":"hash","text":"<p>Computes a hash and returns it as a hex string.</p> <pre><code>serde.hash(algorithm: HashAlgorithm, message: string | buffer) -&gt; string\n</code></pre> <p>Supported algorithms:</p> Algorithm Output Length <code>\"md5\"</code> 32 chars <code>\"sha1\"</code> 40 chars <code>\"sha224\"</code> 56 chars <code>\"sha256\"</code> 64 chars <code>\"sha384\"</code> 96 chars <code>\"sha512\"</code> 128 chars <code>\"sha3-224\"</code> 56 chars <code>\"sha3-256\"</code> 64 chars <code>\"sha3-384\"</code> 96 chars <code>\"sha3-512\"</code> 128 chars <code>\"blake3\"</code> 64 chars"},{"location":"api/serde/#hmac","title":"hmac","text":"<p>Computes HMAC signature and returns it as base64 string.</p> <pre><code>serde.hmac(algorithm: HashAlgorithm, message: string | buffer, secret: string | buffer) -&gt; string\n</code></pre>"},{"location":"api/serde/#examples","title":"Examples","text":"<pre><code>local serde = require(\"@lux/serde\")\n\n-- JSON\nlocal data = { name = \"Lux\", version = 1 }\nlocal json = serde.encode(\"json\", data)\nprint(json) -- {\"name\":\"Lux\",\"version\":1}\n\nlocal parsed = serde.decode(\"json\", json)\nprint(parsed.name) -- Lux\n\n-- Pretty JSON\nlocal pretty = serde.encode(\"json\", data, true)\nprint(pretty)\n\n-- TOML\nlocal toml = serde.encode(\"toml\", { server = { port = 8080 } })\nprint(toml)\n\n-- Compression\nlocal compressed = serde.compress(\"gzip\", \"Hello, World!\")\nlocal decompressed = serde.decompress(\"gzip\", compressed)\nprint(decompressed) -- Hello, World!\n\n-- Hashing\nlocal hash = serde.hash(\"sha256\", \"Hello\")\nprint(hash) -- 64-character hex string\n\n-- HMAC\nlocal signature = serde.hmac(\"sha256\", \"message\", \"secret\")\nprint(signature)\n</code></pre>"},{"location":"api/signal/","title":"signal","text":"<p>High-performance event system.</p> <pre><code>local Signal = require(\"@lux/signal\")\n</code></pre>"},{"location":"api/signal/#constructors","title":"Constructors","text":""},{"location":"api/signal/#new","title":"new","text":"<p>Creates a new Signal.</p> <pre><code>Signal.new() -&gt; Signal\n</code></pre>"},{"location":"api/signal/#methods","title":"Methods","text":""},{"location":"api/signal/#connect","title":"Connect","text":"<p>Connects a function to the signal. Returns a Connection.</p> <pre><code>Signal:Connect(callback: (...any) -&gt; ()) -&gt; Connection\n</code></pre>"},{"location":"api/signal/#once","title":"Once","text":"<p>Connects a function that runs only once.</p> <pre><code>Signal:Once(callback: (...any) -&gt; ()) -&gt; Connection\n</code></pre>"},{"location":"api/signal/#fire","title":"Fire","text":"<p>Fires the signal with arguments.</p> <pre><code>Signal:Fire(...: any) -&gt; ()\n</code></pre>"},{"location":"api/signal/#wait","title":"Wait","text":"<p>Yields until the signal is fired.</p> <pre><code>Signal:Wait() -&gt; ()\n</code></pre>"},{"location":"api/signal/#disconnectall","title":"DisconnectAll","text":"<p>Disconnects all connections.</p> <pre><code>Signal:DisconnectAll() -&gt; ()\n</code></pre>"},{"location":"api/signal/#destroy","title":"Destroy","text":"<p>Alias for DisconnectAll.</p> <pre><code>Signal:Destroy() -&gt; ()\n</code></pre>"},{"location":"api/signal/#getconnections","title":"GetConnections","text":"<p>Returns the number of active connections.</p> <pre><code>Signal:GetConnections() -&gt; number\n</code></pre>"},{"location":"api/signal/#connection","title":"Connection","text":"<p>Represents a connection to a signal.</p>"},{"location":"api/signal/#disconnect","title":"Disconnect","text":"<p>Disconnects the listener.</p> <pre><code>Connection:Disconnect() -&gt; ()\n</code></pre>"},{"location":"api/signal/#connected","title":"Connected","text":"<p>Property checking if connected.</p> <pre><code>Connection.Connected: boolean\n</code></pre>"},{"location":"api/stdio/","title":"stdio","text":"<p>Console input/output and prompts.</p> <pre><code>local stdio = require(\"@lux/stdio\")\n</code></pre>"},{"location":"api/stdio/#write","title":"write","text":"<p>Writes to stdout without newline.</p> <pre><code>stdio.write(s: string) -&gt; ()\n</code></pre>"},{"location":"api/stdio/#ewrite","title":"ewrite","text":"<p>Writes to stderr without newline.</p> <pre><code>stdio.ewrite(s: string) -&gt; ()\n</code></pre>"},{"location":"api/stdio/#readline","title":"readLine","text":"<p>Reads a single line from stdin.</p> <pre><code>stdio.readLine() -&gt; string\n</code></pre>"},{"location":"api/stdio/#readtoend","title":"readToEnd","text":"<p>Reads all input from stdin.</p> <pre><code>stdio.readToEnd() -&gt; string\n</code></pre>"},{"location":"api/stdio/#format","title":"format","text":"<p>Formats values into a human-readable string with syntax highlighting for tables.</p> <pre><code>stdio.format(...: any) -&gt; string\n</code></pre>"},{"location":"api/stdio/#color","title":"color","text":"<p>Returns ANSI color escape code.</p> <pre><code>stdio.color(color: Color) -&gt; string\n</code></pre> <p>Available colors:</p> Color <code>\"reset\"</code> <code>\"black\"</code> <code>\"red\"</code> <code>\"green\"</code> <code>\"yellow\"</code> <code>\"blue\"</code> <code>\"purple\"</code> <code>\"cyan\"</code> <code>\"white\"</code>"},{"location":"api/stdio/#style","title":"style","text":"<p>Returns ANSI style escape code.</p> <pre><code>stdio.style(style: Style) -&gt; string\n</code></pre> <p>Available styles:</p> Style <code>\"reset\"</code> <code>\"bold\"</code> <code>\"dim\"</code>"},{"location":"api/stdio/#prompt","title":"prompt","text":"<p>Interactive prompts for user input.</p> <pre><code>stdio.prompt() -&gt; string\nstdio.prompt(kind: \"text\", message: string?, default: string?) -&gt; string\nstdio.prompt(kind: \"confirm\", message: string, default: boolean?) -&gt; boolean\nstdio.prompt(kind: \"select\", message: string?, options: { string }) -&gt; number?\nstdio.prompt(kind: \"multiselect\", message: string?, options: { string }) -&gt; { number }?\n</code></pre> <p>Prompt kinds:</p> Kind Returns Description <code>\"text\"</code> <code>string</code> Plain text input <code>\"confirm\"</code> <code>boolean</code> Yes/no confirmation <code>\"select\"</code> <code>number?</code> Single selection from list (returns index) <code>\"multiselect\"</code> <code>{ number }?</code> Multiple selections (returns indices)"},{"location":"api/stdio/#examples","title":"Examples","text":"<pre><code>local stdio = require(\"@lux/stdio\")\n\n-- Writing\nstdio.write(\"Hello, \")\nstdio.write(\"World!\")\nprint() -- newline\n\n-- Colors\nlocal red = stdio.color(\"red\")\nlocal reset = stdio.color(\"reset\")\nprint(red .. \"Error!\" .. reset)\n\n-- Styles\nlocal bold = stdio.style(\"bold\")\nprint(bold .. \"Important\" .. stdio.style(\"reset\"))\n\n-- Format\nlocal formatted = stdio.format({ key = \"value\", nested = { 1, 2, 3 } })\nprint(formatted)\n\n-- Prompts\nlocal name = stdio.prompt(\"text\", \"Enter your name:\", \"Guest\")\nprint(\"Hello, \" .. name)\n\nlocal confirmed = stdio.prompt(\"confirm\", \"Continue?\", true)\nif confirmed then print(\"Continuing...\") end\n\nlocal choice = stdio.prompt(\"select\", \"Pick one:\", { \"Option A\", \"Option B\", \"Option C\" })\nif choice then print(\"You chose option\", choice) end\n\nlocal choices = stdio.prompt(\"multiselect\", \"Pick multiple:\", { \"Red\", \"Green\", \"Blue\" })\nif choices then\n    for _, i in choices do print(\"Selected:\", i) end\nend\n\n-- Read from stdin (useful for piped input)\n-- echo \"Hello\" | lux run script.luau\nlocal input = stdio.readToEnd()\nprint(\"Received:\", input)\n</code></pre>"},{"location":"api/task/","title":"task","text":"<p>Task scheduling with cooperative multitasking.</p> <pre><code>local task = require(\"@lux/task\")\n</code></pre>"},{"location":"api/task/#spawn","title":"spawn","text":"<p>Instantly runs a function or thread. If the spawned task yields, the parent thread resumes.</p> <pre><code>task.spawn&lt;T...&gt;(functionOrThread: thread | (T...) -&gt; ...any, ...: T...) -&gt; thread\n</code></pre>"},{"location":"api/task/#defer","title":"defer","text":"<p>Schedules a function to run at the end of the current task queue.</p> <pre><code>task.defer&lt;T...&gt;(functionOrThread: thread | (T...) -&gt; ...any, ...: T...) -&gt; thread\n</code></pre>"},{"location":"api/task/#delay","title":"delay","text":"<p>Schedules a function to run after a delay (in seconds).</p> <pre><code>task.delay&lt;T...&gt;(duration: number, functionOrThread: thread | (T...) -&gt; ...any, ...: T...) -&gt; thread\n</code></pre>"},{"location":"api/task/#wait","title":"wait","text":"<p>Pauses execution for at least the specified duration. Returns actual time waited.</p> <pre><code>task.wait(duration: number?) -&gt; number\n</code></pre> <p>Note</p> <p>Minimum wait accuracy is limited by the OS sleep implementation (typically ~5ms).</p>"},{"location":"api/task/#cancel","title":"cancel","text":"<p>Cancels a scheduled thread.</p> <pre><code>task.cancel(thread: thread) -&gt; ()\n</code></pre>"},{"location":"api/task/#examples","title":"Examples","text":"<pre><code>local task = require(\"@lux/task\")\n\n-- Wait\nprint(\"Starting\")\nlocal elapsed = task.wait(1)\nprint(\"Waited\", elapsed, \"seconds\")\n\n-- Spawn concurrent task\ntask.spawn(function()\n    print(\"Task running\")\n    task.wait(0.5)\n    print(\"Task done\")\nend)\nprint(\"Main continues immediately\")\n\n-- Delay\ntask.delay(2, function()\n    print(\"Runs after 2 seconds\")\nend)\n\n-- Defer\ntask.defer(function()\n    print(\"Runs after current function\")\nend)\nprint(\"Runs first\")\n\n-- Cancel\nlocal t = task.delay(5, function()\n    print(\"This won't run\")\nend)\ntask.cancel(t)\n\n-- Parallel tasks\nfor i = 1, 3 do\n    task.spawn(function()\n        task.wait(i * 0.1)\n        print(\"Task\", i)\n    end)\nend\ntask.wait(1)\n</code></pre>"},{"location":"api/uuid/","title":"UUID","text":"<p>Generate and manipulate UUIDs (Universally Unique Identifiers).</p> <pre><code>local uuid = require(\"@lux/uuid\")\n</code></pre>"},{"location":"api/uuid/#overview","title":"Overview","text":"<p>UUIDs are 128-bit identifiers that are globally unique. This library supports:</p> <ul> <li>UUID v4: Random-based (most common)</li> <li>UUID v7: Timestamp-based, sortable by creation time</li> </ul>"},{"location":"api/uuid/#functions","title":"Functions","text":""},{"location":"api/uuid/#uuidv4","title":"<code>uuid.v4()</code>","text":"<p>Generates a random UUID (version 4).</p> <pre><code>local id = uuid.v4()\nprint(id) -- \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre> <p>Returns: <code>string</code> - A 36-character UUID string</p>"},{"location":"api/uuid/#uuidv7","title":"<code>uuid.v7()</code>","text":"<p>Generates a timestamp-based UUID (version 7). UUIDs generated later sort after earlier ones.</p> <pre><code>local id1 = uuid.v7()\ntask.wait(0.001)\nlocal id2 = uuid.v7()\n-- id2 &gt; id1 when sorted alphabetically\n</code></pre> <p>Returns: <code>string</code> - A 36-character sortable UUID string</p>"},{"location":"api/uuid/#uuidisvalids","title":"<code>uuid.isValid(s)</code>","text":"<p>Validates if a string is a valid UUID format.</p> <pre><code>uuid.isValid(\"550e8400-e29b-41d4-a716-446655440000\") -- true\nuuid.isValid(\"not-a-uuid\") -- false\n</code></pre> Parameter Type Description <code>s</code> <code>string</code> The string to validate <p>Returns: <code>boolean</code></p>"},{"location":"api/uuid/#uuidparses","title":"<code>uuid.parse(s)</code>","text":"<p>Parses a UUID string into a 16-byte buffer.</p> <pre><code>local buf = uuid.parse(\"550e8400-e29b-41d4-a716-446655440000\")\nprint(#buffer.tostring(buf)) -- 16\n</code></pre> Parameter Type Description <code>s</code> <code>string</code> A valid UUID string <p>Returns: <code>buffer?</code> - 16-byte buffer, or <code>nil</code> if invalid</p>"},{"location":"api/uuid/#uuidformatbuf","title":"<code>uuid.format(buf)</code>","text":"<p>Formats a 16-byte buffer as a UUID string.</p> <pre><code>local buf = uuid.parse(id)\nlocal str = uuid.format(buf)\n-- str == id\n</code></pre> Parameter Type Description <code>buf</code> <code>buffer</code> A 16-byte buffer <p>Returns: <code>string</code> - The formatted UUID</p>"},{"location":"api/uuid/#constants","title":"Constants","text":""},{"location":"api/uuid/#uuidnil","title":"<code>uuid.nil</code>","text":"<p>The nil UUID constant (all zeros).</p> <pre><code>print(uuid[\"nil\"]) -- \"00000000-0000-0000-0000-000000000000\"\n</code></pre>"},{"location":"api/uuid/#use-cases","title":"Use Cases","text":"<pre><code>-- Database primary keys\nlocal userId = uuid.v4()\n\n-- Time-ordered records (sortable)\nlocal eventId = uuid.v7()\n\n-- Check if valid before processing\nif uuid.isValid(inputId) then\n    processId(inputId)\nend\n</code></pre>"},{"location":"guides/async/","title":"Async Programming","text":"<p>Lux uses cooperative multitasking with the <code>task</code> module.</p>"},{"location":"guides/async/#core-concepts","title":"Core Concepts","text":"<p>Tasks are Lua coroutines managed by a scheduler. Tasks run until they yield (via <code>task.wait</code>, I/O operations, etc.), then other tasks get a chance to run.</p>"},{"location":"guides/async/#the-scheduler","title":"The Scheduler","text":"<p>Lux's scheduler runs in a loop:</p> <ol> <li>Run ready tasks</li> <li>Check for completed I/O</li> <li>Check for timers</li> <li>Repeat</li> </ol>"},{"location":"guides/async/#functions","title":"Functions","text":"Function Description <code>task.spawn(fn, ...)</code> Run function immediately, return if it yields <code>task.defer(fn, ...)</code> Run after current function completes <code>task.delay(secs, fn, ...)</code> Run after delay <code>task.wait(secs)</code> Pause current task <code>task.cancel(thread)</code> Cancel a scheduled task"},{"location":"guides/async/#examples","title":"Examples","text":""},{"location":"guides/async/#basic-spawn","title":"Basic Spawn","text":"<pre><code>local task = require(\"@lux/task\")\n\ntask.spawn(function()\n    print(\"Running in background\")\n    task.wait(0.5)\n    print(\"After wait\")\nend)\n\nprint(\"Main continues\")\ntask.wait(1)\n</code></pre> <p>Output: <pre><code>Running in background\nMain continues\nAfter wait\n</code></pre></p>"},{"location":"guides/async/#passing-arguments","title":"Passing Arguments","text":"<pre><code>task.spawn(function(name, count)\n    for i = 1, count do\n        print(\"Hello, \" .. name)\n        task.wait(0.1)\n    end\nend, \"World\", 3)\n</code></pre>"},{"location":"guides/async/#delay","title":"Delay","text":"<pre><code>task.delay(2, function()\n    print(\"This runs after 2 seconds\")\nend)\n\nprint(\"Set up delay, now waiting...\")\ntask.wait(3)\n</code></pre>"},{"location":"guides/async/#defer","title":"Defer","text":"<p>Deferred functions run after the current function returns:</p> <pre><code>task.defer(function()\n    print(\"Runs second\")\nend)\n\nprint(\"Runs first\")\n</code></pre> <p>Output: <pre><code>Runs first\nRuns second\n</code></pre></p>"},{"location":"guides/async/#cancel","title":"Cancel","text":"<pre><code>local t = task.delay(5, function()\n    print(\"This won't run\")\nend)\n\ntask.cancel(t)\nprint(\"Task cancelled\")\n</code></pre>"},{"location":"guides/async/#parallel-execution","title":"Parallel Execution","text":"<p>Run multiple tasks concurrently:</p> <pre><code>local task = require(\"@lux/task\")\n\nlocal function download(url, delay)\n    task.wait(delay)\n    return \"Data from \" .. url\nend\n\n-- Start all downloads concurrently\nlocal results = {}\n\ntask.spawn(function()\n    results[1] = download(\"url1\", 0.3)\nend)\n\ntask.spawn(function()\n    results[2] = download(\"url2\", 0.1)\nend)\n\ntask.spawn(function()\n    results[3] = download(\"url3\", 0.2)\nend)\n\n-- Wait for all to complete\ntask.wait(0.5)\n\nfor i, result in results do\n    print(i, result)\nend\n</code></pre>"},{"location":"guides/async/#waiting-for-multiple-tasks","title":"Waiting for Multiple Tasks","text":"<pre><code>local task = require(\"@lux/task\")\n\nlocal function runAll(tasks)\n    local completed = 0\n    local total = #tasks\n\n    for _, taskFn in tasks do\n        task.spawn(function()\n            taskFn()\n            completed = completed + 1\n        end)\n    end\n\n    while completed &lt; total do\n        task.wait(0.01)\n    end\nend\n\nrunAll({\n    function() task.wait(0.1); print(\"Task 1 done\") end,\n    function() task.wait(0.2); print(\"Task 2 done\") end,\n    function() task.wait(0.3); print(\"Task 3 done\") end,\n})\n\nprint(\"All tasks complete!\")\n</code></pre>"},{"location":"guides/async/#timeout-pattern","title":"Timeout Pattern","text":"<pre><code>local task = require(\"@lux/task\")\n\nlocal function withTimeout(fn, timeoutSecs)\n    local done = false\n    local result = nil\n    local timedOut = false\n\n    -- Worker\n    task.spawn(function()\n        result = fn()\n        done = true\n    end)\n\n    -- Timeout\n    task.delay(timeoutSecs, function()\n        if not done then\n            timedOut = true\n        end\n    end)\n\n    -- Wait\n    while not done and not timedOut do\n        task.wait(0.01)\n    end\n\n    if timedOut then\n        return nil, \"timeout\"\n    end\n    return result\nend\n\n-- Usage\nlocal result, err = withTimeout(function()\n    task.wait(0.5)\n    return \"success\"\nend, 1)\n\nprint(result, err) -- success, nil\n</code></pre>"},{"location":"guides/async/#polling-pattern","title":"Polling Pattern","text":"<pre><code>local task = require(\"@lux/task\")\nlocal fs = require(\"@lux/fs\")\n\nlocal function pollFile(path, interval)\n    while not fs.isFile(path) do\n        print(\"Waiting for file...\")\n        task.wait(interval)\n    end\n    return fs.readFile(path)\nend\n\n-- Usage (blocks until file exists)\nlocal content = pollFile(\"result.txt\", 1)\n</code></pre>"},{"location":"guides/async/#best-practices","title":"Best Practices","text":"<ol> <li>Always yield in long loops - Prevents blocking other tasks</li> <li>Use defer for cleanup - Runs even if function errors</li> <li>Keep tasks focused - One responsibility per task</li> <li>Handle errors with pcall - Errors in tasks are silently ignored</li> </ol> <pre><code>-- Good: yields in loop\nwhile true do\n    doWork()\n    task.wait(0.1)\nend\n\n-- Bad: blocks everything\nwhile true do\n    doHeavyWork()  -- No yield!\nend\n</code></pre>"},{"location":"guides/datetime/","title":"Date and Time Guide","text":"<p>Complete guide to using the <code>datetime</code> module.</p>"},{"location":"guides/datetime/#current-time","title":"Current Time","text":"<pre><code>local datetime = require(\"@lux/datetime\")\n\nlocal now = datetime.now()\nprint(now.unixTimestamp)       -- Seconds since epoch\nprint(now.unixTimestampMillis) -- Milliseconds since epoch\n</code></pre>"},{"location":"guides/datetime/#creating-datetime-objects","title":"Creating DateTime Objects","text":""},{"location":"guides/datetime/#from-unix-timestamp","title":"From Unix Timestamp","text":"<pre><code>-- From seconds\nlocal dt = datetime.fromUnixTimestamp(1703520000)\nprint(dt:toRfc3339()) -- 2023-12-25T17:20:00Z\n\n-- With milliseconds (fractional)\nlocal precise = datetime.fromUnixTimestamp(1703520000.500)\n</code></pre>"},{"location":"guides/datetime/#from-components","title":"From Components","text":"<pre><code>-- UTC time\nlocal utc = datetime.fromUniversalTime({\n    year = 2024,\n    month = 12,\n    day = 25,\n    hour = 12,\n    minute = 0,\n    second = 0,\n    millisecond = 0\n})\n\n-- Local time\nlocal local = datetime.fromLocalTime({\n    year = 2024,\n    month = 12,\n    day = 25,\n    hour = 12,\n    minute = 0,\n    second = 0\n})\n</code></pre>"},{"location":"guides/datetime/#from-string-formats","title":"From String Formats","text":"<pre><code>-- RFC 3339 (ISO 8601)\nlocal dt1 = datetime.fromRfc3339(\"2024-12-25T12:00:00Z\")\nlocal dt2 = datetime.fromRfc3339(\"2024-12-25T12:00:00+05:00\")\n\n-- RFC 2822 (email format)\nlocal dt3 = datetime.fromRfc2822(\"Wed, 25 Dec 2024 12:00:00 +0000\")\n</code></pre>"},{"location":"guides/datetime/#formatting","title":"Formatting","text":""},{"location":"guides/datetime/#standard-formats","title":"Standard Formats","text":"<pre><code>local now = datetime.now()\n\nprint(now:toRfc3339())  -- 2024-12-25T12:30:45Z\nprint(now:toRfc2822())  -- Wed, 25 Dec 2024 12:30:45 +0000\nprint(now:toIsoDate())  -- Same as RFC 3339 (deprecated)\n</code></pre>"},{"location":"guides/datetime/#custom-formats","title":"Custom Formats","text":"<pre><code>local now = datetime.now()\n\n-- Using strftime tokens\nprint(now:formatLocalTime(\"%Y-%m-%d\"))           -- 2024-12-25\nprint(now:formatLocalTime(\"%H:%M:%S\"))           -- 12:30:45\nprint(now:formatLocalTime(\"%Y-%m-%d %H:%M:%S\"))  -- 2024-12-25 12:30:45\nprint(now:formatLocalTime(\"%A, %B %d, %Y\"))      -- Wednesday, December 25, 2024\n\n-- UTC formatting\nprint(now:formatUniversalTime(\"%Y-%m-%d %H:%M:%S UTC\"))\n</code></pre>"},{"location":"guides/datetime/#localized-formatting","title":"Localized Formatting","text":"<pre><code>local now = datetime.now()\n\n-- French\nprint(now:formatLocalTime(\"%A, %d %B %Y\", \"fr\"))\n-- mercredi, 25 d\u00e9cembre 2024\n\n-- German\nprint(now:formatLocalTime(\"%A, %d %B %Y\", \"de\"))\n-- Mittwoch, 25 Dezember 2024\n\n-- Portuguese (Brazil)\nprint(now:formatLocalTime(\"%A, %d de %B de %Y\", \"pt-br\"))\n</code></pre> <p>Supported locales: <code>en</code>, <code>de</code>, <code>es</code>, <code>fr</code>, <code>it</code>, <code>ja</code>, <code>pl</code>, <code>pt</code>, <code>pt-br</code>, <code>tr</code></p>"},{"location":"guides/datetime/#extracting-components","title":"Extracting Components","text":"<pre><code>local now = datetime.now()\n\n-- Local time components\nlocal local = now:toLocalTime()\nprint(\"Year:\", local.year)\nprint(\"Month:\", local.month)\nprint(\"Day:\", local.day)\nprint(\"Hour:\", local.hour)\nprint(\"Minute:\", local.minute)\nprint(\"Second:\", local.second)\nprint(\"Millisecond:\", local.millisecond)\n\n-- UTC components\nlocal utc = now:toUniversalTime()\nprint(\"UTC Hour:\", utc.hour)\n</code></pre>"},{"location":"guides/datetime/#format-tokens-reference","title":"Format Tokens Reference","text":"Token Description Example <code>%Y</code> Year (4 digits) 2024 <code>%y</code> Year (2 digits) 24 <code>%m</code> Month (01-12) 12 <code>%d</code> Day (01-31) 25 <code>%H</code> Hour 24h (00-23) 14 <code>%I</code> Hour 12h (01-12) 02 <code>%M</code> Minute (00-59) 30 <code>%S</code> Second (00-59) 45 <code>%p</code> AM/PM PM <code>%A</code> Full weekday Wednesday <code>%a</code> Short weekday Wed <code>%B</code> Full month December <code>%b</code> Short month Dec <code>%j</code> Day of year 360 <code>%w</code> Day of week (0-6) 3 <code>%Z</code> Timezone name UTC <code>%z</code> Timezone offset +0000 <code>%%</code> Literal % %"},{"location":"guides/datetime/#complete-example-log-timestamps","title":"Complete Example: Log Timestamps","text":"<pre><code>local datetime = require(\"@lux/datetime\")\nlocal fs = require(\"@lux/fs\")\n\nlocal function log(level, message)\n    local now = datetime.now()\n    local timestamp = now:formatLocalTime(\"%Y-%m-%d %H:%M:%S\")\n    local line = string.format(\"[%s] [%s] %s\\n\", timestamp, level, message)\n\n    print(line)\n\n    -- Append to log file\n    local logFile = \"app.log\"\n    local existing = fs.isFile(logFile) and fs.readFile(logFile) or \"\"\n    fs.writeFile(logFile, existing .. line)\nend\n\nlog(\"INFO\", \"Application started\")\nlog(\"DEBUG\", \"Loading configuration\")\nlog(\"ERROR\", \"Connection failed\")\n</code></pre>"},{"location":"guides/datetime/#complete-example-time-ago","title":"Complete Example: Time Ago","text":"<pre><code>local datetime = require(\"@lux/datetime\")\n\nlocal function timeAgo(timestamp)\n    local now = datetime.now().unixTimestamp\n    local diff = now - timestamp\n\n    if diff &lt; 60 then\n        return math.floor(diff) .. \" seconds ago\"\n    elseif diff &lt; 3600 then\n        return math.floor(diff / 60) .. \" minutes ago\"\n    elseif diff &lt; 86400 then\n        return math.floor(diff / 3600) .. \" hours ago\"\n    else\n        return math.floor(diff / 86400) .. \" days ago\"\n    end\nend\n\nlocal pastTime = datetime.now().unixTimestamp - 3700\nprint(timeAgo(pastTime)) -- 1 hours ago\n</code></pre>"},{"location":"guides/ffi/","title":"FFI Guide","text":"<p>Using the Foreign Function Interface to call native C libraries.</p>"},{"location":"guides/ffi/#defining-types","title":"Defining Types","text":"<p>Use <code>ffi.cdef</code> to declare C types:</p> <pre><code>local ffi = require(\"@lux/ffi\")\n\nffi.cdef[[\n    typedef struct Point {\n        int x;\n        int y;\n    } Point;\n]]\n</code></pre>"},{"location":"guides/ffi/#creating-instances","title":"Creating Instances","text":"<pre><code>local point = ffi.new(\"Point\")\npoint.x = 100\npoint.y = 200\nprint(point.x, point.y)\n</code></pre>"},{"location":"guides/ffi/#type-sizes","title":"Type Sizes","text":"<pre><code>print(ffi.sizeof(\"int\"))      -- 4\nprint(ffi.sizeof(\"double\"))   -- 8\nprint(ffi.sizeof(\"Point\"))    -- 8\n</code></pre>"},{"location":"guides/ffi/#arrays","title":"Arrays","text":""},{"location":"guides/ffi/#fixed-size-in-struct","title":"Fixed-size in Struct","text":"<pre><code>ffi.cdef[[\n    typedef struct Buffer {\n        char data[256];\n    } Buffer;\n]]\n\nlocal buf = ffi.new(\"Buffer\")\n</code></pre>"},{"location":"guides/ffi/#variable-length-arrays","title":"Variable-length Arrays","text":"<p>Use <code>[?]</code> and pass size:</p> <pre><code>local arr = ffi.new(\"int[?]\", 1000)\n\n-- 0-indexed access\narr[0] = 42\narr[999] = 100\n</code></pre>"},{"location":"guides/ffi/#nested-structs","title":"Nested Structs","text":"<pre><code>ffi.cdef[[\n    typedef struct Point { int x, y; } Point;\n    typedef struct Rectangle {\n        Point origin;\n        Point size;\n    } Rectangle;\n]]\n\nlocal rect = ffi.new(\"Rectangle\")\nrect.origin.x = 0\nrect.origin.y = 0\nrect.size.x = 100\nrect.size.y = 50\n</code></pre>"},{"location":"guides/ffi/#enums","title":"Enums","text":"<pre><code>ffi.cdef[[\n    typedef enum Color {\n        RED = 0,\n        GREEN = 1,\n        BLUE = 2\n    } Color;\n]]\n</code></pre>"},{"location":"guides/ffi/#using-system-libraries","title":"Using System Libraries","text":"<pre><code>ffi.cdef[[\n    int printf(const char* fmt, ...);\n]]\n\nffi.C.printf(\"Hello from C!\\n\")\n</code></pre>"},{"location":"guides/ffi/#loading-custom-libraries","title":"Loading Custom Libraries","text":"<pre><code>local mylib = ffi.load(\"mylib.dll\")\n\nffi.cdef[[\n    int myFunction(int a, int b);\n]]\n\nlocal result = mylib.myFunction(10, 20)\n</code></pre>"},{"location":"guides/ffi/#callbacks","title":"Callbacks","text":"<pre><code>local cb = ffi.callback(\"int(*)(int, int)\", function(a, b)\n    return a + b\nend)\n</code></pre>"},{"location":"guides/ffi/#memory-operations","title":"Memory Operations","text":"<pre><code>local buf = ffi.new(\"char[?]\", 100)\n\n-- Zero fill\nffi.fill(buf, 100, 0)\n\n-- Copy\nlocal src = ffi.new(\"char[?]\", 10)\nffi.copy(buf, src, 10)\n</code></pre>"},{"location":"guides/ffi/#best-practices","title":"Best Practices","text":"<ol> <li>Define types with <code>cdef</code> before using <code>new</code></li> <li>Arrays are 0-indexed (C convention)</li> <li>Use <code>sizeof</code> to verify type sizes</li> <li>Wrap calls in <code>pcall</code> for error handling</li> </ol>"},{"location":"guides/ffi/#high-performance","title":"High Performance","text":""},{"location":"guides/ffi/#batch-processing","title":"Batch Processing","text":"<p>When working with many C structs in a loop (e.g., thousands of particles), creating new standard CData objects for each iteration can cause GC pressure.</p> <p>The <code>ffi.batch</code> and <code>ffi.batch2</code> functions provide a way to allocate memory once and reuse it or manage it manually.</p> <pre><code>-- Batch2 for array-like access\nlocal batch = ffi.batch2(\"Point\", 1000)\n\nfor i = 0, 999 do\n    local p = batch[i] -- No allocation, returns reference to internal memory\n    p.x = i\n    p.y = i * 2\nend\n</code></pre>"},{"location":"guides/files/","title":"File I/O","text":"<p>Working with files using the <code>fs</code> module.</p>"},{"location":"guides/files/#reading-files","title":"Reading Files","text":"<pre><code>local fs = require(\"@lux/fs\")\n\nlocal content = fs.readFile(\"config.json\")\nprint(content)\n</code></pre>"},{"location":"guides/files/#writing-files","title":"Writing Files","text":"<pre><code>fs.writeFile(\"output.txt\", \"Hello, World!\")\n</code></pre>"},{"location":"guides/files/#checking-paths","title":"Checking Paths","text":"<pre><code>if fs.isFile(\"config.json\") then\n    print(\"Config exists\")\nend\n\nif fs.isDir(\"./src\") then\n    print(\"Source directory exists\")\nend\n</code></pre>"},{"location":"guides/files/#listing-directories","title":"Listing Directories","text":"<pre><code>local entries = fs.readDir(\".\")\nfor _, name in entries do\n    print(name)\nend\n</code></pre>"},{"location":"guides/files/#creating-directories","title":"Creating Directories","text":"<p>Creates parents if needed:</p> <pre><code>fs.writeDir(\"./output/logs/2024\")\n</code></pre>"},{"location":"guides/files/#copying-and-moving","title":"Copying and Moving","text":"<pre><code>-- Copy\nfs.copy(\"original.txt\", \"backup.txt\")\n\n-- Move/rename\nfs.move(\"old.txt\", \"new.txt\")\n\n-- Overwrite existing\nfs.copy(\"source.txt\", \"dest.txt\", true)\nfs.move(\"source.txt\", \"dest.txt\", { overwrite = true })\n</code></pre>"},{"location":"guides/files/#deleting","title":"Deleting","text":"<pre><code>fs.removeFile(\"temp.txt\")\nfs.removeDir(\"./temp\")  -- Deletes recursively\n</code></pre>"},{"location":"guides/files/#file-metadata","title":"File Metadata","text":"<pre><code>local meta = fs.metadata(\"file.txt\")\n\nprint(\"Type:\", meta.kind)              -- \"file\", \"dir\", \"symlink\"\nprint(\"Exists:\", meta.exists)\nprint(\"Read-only:\", meta.permissions.readOnly)\nprint(\"Modified:\", meta.modifiedAt.unixTimestamp)\n</code></pre>"},{"location":"guides/files/#error-handling","title":"Error Handling","text":"<pre><code>local ok, result = pcall(function()\n    return fs.readFile(\"nonexistent.txt\")\nend)\n\nif ok then\n    print(result)\nelse\n    print(\"Error:\", result)\nend\n</code></pre>"},{"location":"guides/files/#complete-example","title":"Complete Example","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal serde = require(\"@lux/serde\")\n\n-- Create project structure\nfs.writeDir(\"./project/src\")\nfs.writeDir(\"./project/tests\")\n\n-- Write config\nlocal config = { name = \"my-app\", version = \"1.0.0\" }\nfs.writeFile(\n    \"./project/config.json\",\n    serde.encode(\"json\", config, true)  -- pretty print\n)\n\n-- Write main script\nfs.writeFile(\"./project/src/main.luau\", [[\nprint(\"Hello!\")\n]])\n\n-- List files\nprint(\"Files:\")\nfor _, name in fs.readDir(\"./project\") do\n    local path = \"./project/\" .. name\n    local kind = fs.isDir(path) and \"dir\" or \"file\"\n    print(\"  \" .. name .. \" (\" .. kind .. \")\")\nend\n</code></pre>"},{"location":"guides/process/","title":"Process and Commands Guide","text":"<p>Complete guide to using the <code>process</code> module for system interaction.</p>"},{"location":"guides/process/#environment-information","title":"Environment Information","text":"<pre><code>local process = require(\"@lux/process\")\n\n-- Operating system\nprint(\"OS:\", process.os)        -- \"windows\", \"linux\", or \"macos\"\nprint(\"Arch:\", process.arch)    -- \"x86_64\" or \"aarch64\"\nprint(\"Endianness:\", process.endianness) -- \"little\" or \"big\"\n\n-- Current directory\nprint(\"CWD:\", process.cwd)\n</code></pre>"},{"location":"guides/process/#command-line-arguments","title":"Command Line Arguments","text":"<p>Arguments passed to your script:</p> <pre><code>-- Running: lux script.luau arg1 arg2\n\nfor i, arg in process.args do\n    print(\"Arg \" .. i .. \":\", arg)\nend\n-- Arg 1: arg1\n-- Arg 2: arg2\n</code></pre>"},{"location":"guides/process/#environment-variables","title":"Environment Variables","text":""},{"location":"guides/process/#reading","title":"Reading","text":"<pre><code>-- Get specific variables\nprint(\"PATH:\", process.env.PATH)\nprint(\"HOME:\", process.env.HOME)\nprint(\"USER:\", process.env.USER)\n\n-- Iterate all\nfor name, value in process.env do\n    print(name .. \"=\" .. value)\nend\n</code></pre>"},{"location":"guides/process/#setting","title":"Setting","text":"<pre><code>-- Set for current process\nprocess.env.MY_VAR = \"hello\"\nprint(process.env.MY_VAR) -- hello\n\n-- Unset\nprocess.env.MY_VAR = nil\n</code></pre>"},{"location":"guides/process/#executing-commands","title":"Executing Commands","text":""},{"location":"guides/process/#simple-execution-exec","title":"Simple Execution (exec)","text":"<p>Runs command and waits for completion:</p> <pre><code>local result = process.exec(\"echo\", { \"Hello, World!\" })\n\nif result.ok then\n    print(\"Output:\", result.stdout)\nelse\n    print(\"Error:\", result.stderr)\n    print(\"Exit code:\", result.code)\nend\n</code></pre>"},{"location":"guides/process/#with-options","title":"With Options","text":"<pre><code>local result = process.exec(\"ls\", { \"-la\" }, {\n    cwd = \"/tmp\",                    -- Working directory\n    env = { MY_VAR = \"value\" },      -- Additional env vars\n})\n</code></pre>"},{"location":"guides/process/#shell-commands","title":"Shell Commands","text":"<pre><code>-- Use shell for pipes, redirects, etc.\nlocal result = process.exec(\"echo hello &amp;&amp; echo world\", nil, {\n    shell = true  -- Use default shell\n})\n\n-- Or specify shell\nlocal result = process.exec(\"echo hello\", nil, {\n    shell = \"bash\"  -- Use specific shell\n})\n</code></pre>"},{"location":"guides/process/#sending-input-to-stdin","title":"Sending Input to stdin","text":"<pre><code>local result = process.exec(\"cat\", nil, {\n    stdio = {\n        stdin = \"Hello from stdin!\"\n    }\n})\nprint(result.stdout) -- Hello from stdin!\n</code></pre>"},{"location":"guides/process/#output-handling","title":"Output Handling","text":"<pre><code>local result = process.exec(\"node\", { \"-e\", \"console.log('hi')\" }, {\n    stdio = {\n        stdout = \"inherit\",  -- Print to parent stdout\n        stderr = \"inherit\"   -- Print to parent stderr\n    }\n})\n</code></pre>"},{"location":"guides/process/#background-processes-create","title":"Background Processes (create)","text":"<p>For long-running or interactive processes:</p> <pre><code>local child = process.create(\"cat\")\n\n-- Write to stdin\nchild.stdin:write(\"Hello!\\n\")\nchild.stdin:write(\"World!\\n\")\nchild.stdin:close()\n\n-- Read from stdout\nlocal output = child.stdout:readToEnd()\nprint(output)\n\n-- Get exit status\nlocal status = child:status()\nprint(\"Exit code:\", status.code)\n</code></pre>"},{"location":"guides/process/#streaming-output","title":"Streaming Output","text":"<pre><code>local child = process.create(\"ping\", { \"-c\", \"3\", \"google.com\" })\n\n-- Read output as it arrives\nwhile true do\n    local chunk = child.stdout:read()\n    if chunk == nil then break end\n    print(chunk)\nend\n</code></pre>"},{"location":"guides/process/#killing-a-process","title":"Killing a Process","text":"<pre><code>local child = process.create(\"sleep\", { \"100\" })\n\n-- Kill after 1 second\ntask.delay(1, function()\n    child:kill()\n    print(\"Process killed\")\nend)\n</code></pre>"},{"location":"guides/process/#exit","title":"Exit","text":"<p>Exit the script with a code:</p> <pre><code>if errorOccurred then\n    process.exit(1)  -- Error\nend\n\nprocess.exit(0)  -- Success (never reached if above exits)\n</code></pre>"},{"location":"guides/process/#complete-example-build-script","title":"Complete Example: Build Script","text":"<pre><code>local process = require(\"@lux/process\")\nlocal fs = require(\"@lux/fs\")\n\nprint(\"Building project...\")\nprint(\"OS:\", process.os)\nprint(\"CWD:\", process.cwd)\n\n-- Clean\nif fs.isDir(\"build\") then\n    fs.removeDir(\"build\")\nend\nfs.writeDir(\"build\")\n\n-- Run build command\nlocal result = process.exec(\"cargo\", { \"build\", \"--release\" }, {\n    stdio = { stdout = \"inherit\", stderr = \"inherit\" }\n})\n\nif result.ok then\n    print(\"\u2713 Build successful!\")\n    process.exit(0)\nelse\n    print(\"\u2717 Build failed with code:\", result.code)\n    process.exit(1)\nend\n</code></pre>"},{"location":"guides/regex/","title":"Regular Expressions Guide","text":"<p>Complete guide to using the <code>regex</code> module.</p>"},{"location":"guides/regex/#creating-patterns","title":"Creating Patterns","text":"<pre><code>local regex = require(\"@lux/regex\")\n\nlocal pattern = regex.new(\"\\\\d+\")  -- Match digits\n\n-- Note: Use \\\\ for backslash in Luau strings\n</code></pre>"},{"location":"guides/regex/#checking-matches","title":"Checking Matches","text":"<pre><code>local pattern = regex.new(\"\\\\d+\")\n\nprint(pattern:isMatch(\"abc123\"))  -- true\nprint(pattern:isMatch(\"abc\"))     -- false\n</code></pre>"},{"location":"guides/regex/#finding-matches","title":"Finding Matches","text":"<pre><code>local pattern = regex.new(\"\\\\d+\")\nlocal match = pattern:find(\"Price: 42 dollars\")\n\nif match then\n    print(\"Text:\", match.text)    -- 42\n    print(\"Start:\", match.start)  -- 8\n    print(\"End:\", match.finish)   -- 9\n    print(\"Length:\", match.len)   -- 2\nend\n</code></pre>"},{"location":"guides/regex/#capture-groups","title":"Capture Groups","text":""},{"location":"guides/regex/#indexed-groups","title":"Indexed Groups","text":"<pre><code>local pattern = regex.new(\"(\\\\w+)=(\\\\w+)\")\nlocal caps = pattern:captures(\"name=value\")\n\nif caps then\n    print(\"Full:\", caps:get(0).text)   -- name=value\n    print(\"Key:\", caps:get(1).text)    -- name\n    print(\"Value:\", caps:get(2).text)  -- value\nend\n</code></pre>"},{"location":"guides/regex/#named-groups","title":"Named Groups","text":"<pre><code>local pattern = regex.new(\"(?&lt;key&gt;\\\\w+)=(?&lt;value&gt;\\\\w+)\")\nlocal caps = pattern:captures(\"name=value\")\n\nif caps then\n    print(\"Key:\", caps:group(\"key\").text)     -- name\n    print(\"Value:\", caps:group(\"value\").text) -- value\nend\n</code></pre>"},{"location":"guides/regex/#formatting-captures","title":"Formatting Captures","text":"<pre><code>local pattern = regex.new(\"(?&lt;day&gt;\\\\d{2})-(?&lt;month&gt;\\\\d{2})-(?&lt;year&gt;\\\\d{4})\")\nlocal caps = pattern:captures(\"Date: 25-12-2024\")\n\nif caps then\n    local formatted = caps:format(\"$year/$month/$day\")\n    print(formatted) -- 2024/12/25\nend\n</code></pre>"},{"location":"guides/regex/#splitting-text","title":"Splitting Text","text":"<pre><code>local pattern = regex.new(\",\\\\s*\")  -- Comma and optional whitespace\nlocal parts = pattern:split(\"a, b,c,  d\")\n\nfor _, part in parts do\n    print(part)\nend\n-- a\n-- b\n-- c\n-- d\n</code></pre>"},{"location":"guides/regex/#replacing-text","title":"Replacing Text","text":""},{"location":"guides/regex/#replace-first","title":"Replace First","text":"<pre><code>local pattern = regex.new(\"cat\")\nlocal result = pattern:replace(\"cat dog cat\", \"bird\")\nprint(result) -- bird dog cat\n</code></pre>"},{"location":"guides/regex/#replace-all","title":"Replace All","text":"<pre><code>local pattern = regex.new(\"cat\")\nlocal result = pattern:replaceAll(\"cat dog cat\", \"bird\")\nprint(result) -- bird dog bird\n</code></pre>"},{"location":"guides/regex/#replacing-with-capture-groups","title":"Replacing with Capture Groups","text":"<pre><code>local pattern = regex.new(\"(\\\\w+)@(\\\\w+)\")\nlocal result = pattern:replaceAll(\"user@domain\", \"$2-$1\")\nprint(result) -- domain-user\n</code></pre>"},{"location":"guides/regex/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/regex/#email-validation","title":"Email Validation","text":"<pre><code>local emailPattern = regex.new(\"^[\\\\w.+-]+@[\\\\w-]+\\\\.[\\\\w.-]+$\")\n\nprint(emailPattern:isMatch(\"user@example.com\"))  -- true\nprint(emailPattern:isMatch(\"invalid\"))           -- false\n</code></pre>"},{"location":"guides/regex/#url-extraction","title":"URL Extraction","text":"<pre><code>local urlPattern = regex.new(\"https?://[\\\\w.-]+(?:/[\\\\w./-]*)?\")\nlocal text = \"Visit https://example.com/path for more info\"\n\nlocal match = urlPattern:find(text)\nif match then\n    print(match.text) -- https://example.com/path\nend\n</code></pre>"},{"location":"guides/regex/#phone-numbers","title":"Phone Numbers","text":"<pre><code>local phonePattern = regex.new(\"\\\\(?(\\\\d{3})\\\\)?[-\\\\s]?(\\\\d{3})[-\\\\s]?(\\\\d{4})\")\n\nlocal caps = phonePattern:captures(\"Call (555) 123-4567\")\nif caps then\n    print(caps:format(\"($1) $2-$3\"))  -- (555) 123-4567\nend\n</code></pre>"},{"location":"guides/regex/#ipv4-address","title":"IPv4 Address","text":"<pre><code>local ipPattern = regex.new(\"\\\\b\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\b\")\n\nprint(ipPattern:isMatch(\"192.168.1.1\"))  -- true\nprint(ipPattern:isMatch(\"999.999.999.999\"))  -- true (format only)\n</code></pre>"},{"location":"guides/regex/#complete-example-log-parser","title":"Complete Example: Log Parser","text":"<pre><code>local regex = require(\"@lux/regex\")\nlocal fs = require(\"@lux/fs\")\n\n-- Log format: [2024-12-25 12:30:45] [INFO] Message\nlocal logPattern = regex.new(\n    \"\\\\[(?&lt;date&gt;[\\\\d-]+)\\\\s(?&lt;time&gt;[\\\\d:]+)\\\\]\\\\s\\\\[(?&lt;level&gt;\\\\w+)\\\\]\\\\s(?&lt;message&gt;.+)\"\n)\n\nlocal function parseLogs(content)\n    local entries = {}\n\n    for line in content:gmatch(\"[^\\n]+\") do\n        local caps = logPattern:captures(line)\n        if caps then\n            table.insert(entries, {\n                date = caps:group(\"date\").text,\n                time = caps:group(\"time\").text,\n                level = caps:group(\"level\").text,\n                message = caps:group(\"message\").text\n            })\n        end\n    end\n\n    return entries\nend\n\n-- Usage\nlocal logs = [[\n[2024-12-25 12:30:45] [INFO] Server started\n[2024-12-25 12:30:46] [DEBUG] Loading config\n[2024-12-25 12:31:00] [ERROR] Connection failed\n]]\n\nlocal entries = parseLogs(logs)\nfor _, entry in entries do\n    print(entry.level .. \": \" .. entry.message)\nend\n</code></pre>"},{"location":"guides/regex/#complete-example-text-sanitizer","title":"Complete Example: Text Sanitizer","text":"<pre><code>local regex = require(\"@lux/regex\")\n\nlocal function sanitize(text)\n    -- Remove HTML tags\n    text = regex.new(\"&lt;[^&gt;]+&gt;\"):replaceAll(text, \"\")\n\n    -- Replace multiple spaces with single\n    text = regex.new(\"\\\\s+\"):replaceAll(text, \" \")\n\n    -- Trim\n    text = text:match(\"^%s*(.-)%s*$\")\n\n    return text\nend\n\nlocal dirty = \"&lt;p&gt;Hello   &lt;b&gt;World&lt;/b&gt;!   &lt;/p&gt;\"\nprint(sanitize(dirty)) -- Hello World!\n</code></pre>"},{"location":"guides/serde/","title":"Serialization Guide","text":"<p>Complete guide to using the <code>serde</code> module for data serialization.</p>"},{"location":"guides/serde/#json","title":"JSON","text":""},{"location":"guides/serde/#encoding","title":"Encoding","text":"<pre><code>local serde = require(\"@lux/serde\")\n\nlocal data = {\n    name = \"Lux\",\n    version = \"0.1.0\",\n    features = { \"async\", \"ffi\", \"fs\" }\n}\n\n-- Compact JSON\nlocal json = serde.encode(\"json\", data)\nprint(json)\n-- {\"features\":[\"async\",\"ffi\",\"fs\"],\"name\":\"Lux\",\"version\":\"0.1.0\"}\n\n-- Pretty JSON (with indentation)\nlocal pretty = serde.encode(\"json\", data, true)\nprint(pretty)\n--[[\n{\n  \"features\": [\n    \"async\",\n    \"ffi\",\n    \"fs\"\n  ],\n  \"name\": \"Lux\",\n  \"version\": \"0.1.0\"\n}\n]]\n</code></pre>"},{"location":"guides/serde/#decoding","title":"Decoding","text":"<pre><code>local jsonStr = '{\"name\":\"Lux\",\"value\":42}'\nlocal data = serde.decode(\"json\", jsonStr)\n\nprint(data.name)  -- Lux\nprint(data.value) -- 42\n</code></pre>"},{"location":"guides/serde/#json-with-comments-jsonc","title":"JSON with Comments (JSONC)","text":"<pre><code>local jsonc = [[\n{\n    // This is a comment\n    \"name\": \"config\",\n    /* Multi-line\n       comment */\n    \"enabled\": true\n}\n]]\n\nlocal config = serde.decode(\"jsonc\", jsonc)\nprint(config.name) -- config\n</code></pre>"},{"location":"guides/serde/#toml","title":"TOML","text":"<p>TOML is ideal for configuration files.</p> <pre><code>local config = {\n    server = {\n        host = \"localhost\",\n        port = 8080\n    },\n    database = {\n        url = \"postgres://localhost/db\"\n    }\n}\n\nlocal toml = serde.encode(\"toml\", config, true)\nprint(toml)\n--[[\n[database]\nurl = \"postgres://localhost/db\"\n\n[server]\nhost = \"localhost\"\nport = 8080\n]]\n\n-- Parse TOML\nlocal parsed = serde.decode(\"toml\", toml)\nprint(parsed.server.port) -- 8080\n</code></pre>"},{"location":"guides/serde/#yaml","title":"YAML","text":"<pre><code>local data = {\n    users = {\n        { name = \"Alice\", role = \"admin\" },\n        { name = \"Bob\", role = \"user\" }\n    }\n}\n\nlocal yaml = serde.encode(\"yaml\", data)\n-- Parse YAML\nlocal parsed = serde.decode(\"yaml\", yaml)\n</code></pre>"},{"location":"guides/serde/#hashing","title":"Hashing","text":""},{"location":"guides/serde/#basic-hashing","title":"Basic Hashing","text":"<pre><code>local hash = serde.hash(\"sha256\", \"Hello, World!\")\nprint(hash) -- 64-character hex string\nprint(#hash) -- 64\n</code></pre>"},{"location":"guides/serde/#all-hash-algorithms","title":"All Hash Algorithms","text":"<pre><code>local message = \"test\"\n\nprint(\"MD5:      \", serde.hash(\"md5\", message))\nprint(\"SHA1:     \", serde.hash(\"sha1\", message))\nprint(\"SHA256:   \", serde.hash(\"sha256\", message))\nprint(\"SHA512:   \", serde.hash(\"sha512\", message))\nprint(\"BLAKE3:   \", serde.hash(\"blake3\", message))\n</code></pre>"},{"location":"guides/serde/#hmac-keyed-hashing","title":"HMAC (Keyed Hashing)","text":"<pre><code>local signature = serde.hmac(\"sha256\", \"message\", \"secret-key\")\nprint(signature) -- Base64 encoded\n</code></pre>"},{"location":"guides/serde/#compression","title":"Compression","text":""},{"location":"guides/serde/#compressing-data","title":"Compressing Data","text":"<pre><code>local data = string.rep(\"Hello, World! \", 1000)\n\nlocal compressed = serde.compress(\"gzip\", data)\nprint(\"Original:\", #data, \"bytes\")\nprint(\"Compressed:\", #compressed, \"bytes\")\n\nlocal decompressed = serde.decompress(\"gzip\", compressed)\nassert(decompressed == data)\n</code></pre>"},{"location":"guides/serde/#compression-formats","title":"Compression Formats","text":"<pre><code>-- Different formats\nlocal gzip = serde.compress(\"gzip\", data)\nlocal zlib = serde.compress(\"zlib\", data)\nlocal brotli = serde.compress(\"brotli\", data)\nlocal lz4 = serde.compress(\"lz4\", data)\nlocal zstd = serde.compress(\"zstd\", data)\n\n-- Compare sizes\nprint(\"gzip:\", #gzip)\nprint(\"zlib:\", #zlib)\nprint(\"brotli:\", #brotli)\nprint(\"lz4:\", #lz4)\nprint(\"zstd:\", #zstd)\n</code></pre>"},{"location":"guides/serde/#compression-levels","title":"Compression Levels","text":"<pre><code>-- Higher level = smaller size, slower\nlocal fast = serde.compress(\"gzip\", data, 1)     -- Fastest\nlocal balanced = serde.compress(\"gzip\", data, 6) -- Default\nlocal best = serde.compress(\"gzip\", data, 9)     -- Best compression\n</code></pre>"},{"location":"guides/serde/#complete-example-config-file","title":"Complete Example: Config File","text":"<pre><code>local fs = require(\"@lux/fs\")\nlocal serde = require(\"@lux/serde\")\n\n-- Load or create config\nlocal configPath = \"config.json\"\nlocal config\n\nif fs.isFile(configPath) then\n    local content = fs.readFile(configPath)\n    config = serde.decode(\"json\", content)\n    print(\"Loaded config\")\nelse\n    config = {\n        server = { host = \"localhost\", port = 8080 },\n        debug = true,\n        version = 1\n    }\n    fs.writeFile(configPath, serde.encode(\"json\", config, true))\n    print(\"Created default config\")\nend\n\nprint(\"Server:\", config.server.host .. \":\" .. config.server.port)\n</code></pre>"},{"location":"guides/stdio/","title":"Console I/O Guide","text":"<p>Complete guide to using the <code>stdio</code> module for console input/output.</p>"},{"location":"guides/stdio/#basic-output","title":"Basic Output","text":"<pre><code>local stdio = require(\"@lux/stdio\")\n\n-- Write without newline\nstdio.write(\"Hello, \")\nstdio.write(\"World!\")\nprint()  -- Add newline\n\n-- Write to stderr\nstdio.ewrite(\"Error message\")\n</code></pre>"},{"location":"guides/stdio/#formatting","title":"Formatting","text":"<p>The <code>format</code> function creates pretty-printed output with syntax highlighting:</p> <pre><code>local stdio = require(\"@lux/stdio\")\n\nlocal data = {\n    name = \"Lux\",\n    version = \"0.1.0\",\n    features = { \"async\", \"ffi\", \"fs\" }\n}\n\nlocal formatted = stdio.format(data)\nprint(formatted)\n--[[\n{\n    features = {\n        [1] = \"async\",\n        [2] = \"ffi\",\n        [3] = \"fs\"\n    },\n    name = \"Lux\",\n    version = \"0.1.0\"\n}\n]]\n</code></pre>"},{"location":"guides/stdio/#colors","title":"Colors","text":"<p>Add color to terminal output:</p> <pre><code>local stdio = require(\"@lux/stdio\")\n\nlocal red = stdio.color(\"red\")\nlocal green = stdio.color(\"green\")\nlocal reset = stdio.color(\"reset\")\n\nprint(red .. \"Error: Something went wrong!\" .. reset)\nprint(green .. \"Success: Operation completed!\" .. reset)\n</code></pre>"},{"location":"guides/stdio/#available-colors","title":"Available Colors","text":"Color Description <code>\"black\"</code> Black text <code>\"red\"</code> Red text <code>\"green\"</code> Green text <code>\"yellow\"</code> Yellow text <code>\"blue\"</code> Blue text <code>\"purple\"</code> Purple/magenta text <code>\"cyan\"</code> Cyan text <code>\"white\"</code> White text <code>\"reset\"</code> Reset to default"},{"location":"guides/stdio/#styles","title":"Styles","text":"<p>Apply text styles:</p> <pre><code>local bold = stdio.style(\"bold\")\nlocal dim = stdio.style(\"dim\")\nlocal reset = stdio.style(\"reset\")\n\nprint(bold .. \"Important message\" .. reset)\nprint(dim .. \"Less important\" .. reset)\n</code></pre>"},{"location":"guides/stdio/#available-styles","title":"Available Styles","text":"Style Description <code>\"bold\"</code> Bold text <code>\"dim\"</code> Dimmed text <code>\"reset\"</code> Reset to default"},{"location":"guides/stdio/#combined-colors-and-styles","title":"Combined Colors and Styles","text":"<pre><code>local stdio = require(\"@lux/stdio\")\n\nlocal function error(msg)\n    local red = stdio.color(\"red\")\n    local bold = stdio.style(\"bold\")\n    local reset = stdio.color(\"reset\")\n    print(bold .. red .. \"ERROR: \" .. reset .. msg)\nend\n\nlocal function success(msg)\n    local green = stdio.color(\"green\")\n    local reset = stdio.color(\"reset\")\n    print(green .. \"\u2713 \" .. reset .. msg)\nend\n\nerror(\"File not found\")\nsuccess(\"Build completed\")\n</code></pre>"},{"location":"guides/stdio/#reading-input","title":"Reading Input","text":""},{"location":"guides/stdio/#read-line","title":"Read Line","text":"<pre><code>local stdio = require(\"@lux/stdio\")\n\nstdio.write(\"Enter your name: \")\nlocal name = stdio.readLine()\nprint(\"Hello, \" .. name)\n</code></pre>"},{"location":"guides/stdio/#read-all-stdin","title":"Read All (stdin)","text":"<p>Useful for piped input:</p> <pre><code>echo \"Hello\" | lux script.luau\n</code></pre> <pre><code>local input = stdio.readToEnd()\nprint(\"Received:\", input)\n</code></pre>"},{"location":"guides/stdio/#interactive-prompts","title":"Interactive Prompts","text":""},{"location":"guides/stdio/#text-input","title":"Text Input","text":"<pre><code>local stdio = require(\"@lux/stdio\")\n\n-- Basic (just read)\nlocal input = stdio.prompt()\n\n-- With message\nlocal name = stdio.prompt(\"text\", \"Enter your name:\")\n\n-- With default value\nlocal name = stdio.prompt(\"text\", \"Enter your name:\", \"Guest\")\n</code></pre>"},{"location":"guides/stdio/#confirmation","title":"Confirmation","text":"<pre><code>-- Default: yes\nlocal confirmed = stdio.prompt(\"confirm\", \"Continue?\")\nprint(confirmed)  -- true or false\n\n-- Default: no\nlocal confirmed = stdio.prompt(\"confirm\", \"Delete file?\", false)\n</code></pre>"},{"location":"guides/stdio/#single-selection","title":"Single Selection","text":"<pre><code>local options = { \"Option A\", \"Option B\", \"Option C\" }\nlocal choice = stdio.prompt(\"select\", \"Pick one:\", options)\n\nif choice then\n    print(\"You chose option\", choice)  -- Returns index (1, 2, or 3)\n    print(\"Selection:\", options[choice])\nend\n</code></pre>"},{"location":"guides/stdio/#multiple-selection","title":"Multiple Selection","text":"<pre><code>local options = { \"Red\", \"Green\", \"Blue\", \"Yellow\" }\nlocal choices = stdio.prompt(\"multiselect\", \"Pick colors:\", options)\n\nif choices then\n    print(\"Selected indices:\", table.concat(choices, \", \"))\n    for _, i in choices do\n        print(\"- \" .. options[i])\n    end\nend\n</code></pre>"},{"location":"guides/stdio/#complete-example-cli-tool","title":"Complete Example: CLI Tool","text":"<pre><code>local stdio = require(\"@lux/stdio\")\nlocal fs = require(\"@lux/fs\")\n\nlocal red = stdio.color(\"red\")\nlocal green = stdio.color(\"green\")\nlocal reset = stdio.color(\"reset\")\nlocal bold = stdio.style(\"bold\")\n\nprint(bold .. \"Project Generator\" .. stdio.style(\"reset\"))\nprint()\n\n-- Get project info\nlocal name = stdio.prompt(\"text\", \"Project name:\", \"my-project\")\nlocal description = stdio.prompt(\"text\", \"Description:\")\n\nlocal templates = { \"Basic\", \"CLI Tool\", \"Library\" }\nlocal templateIdx = stdio.prompt(\"select\", \"Template:\", templates)\n\nlocal features = { \"Tests\", \"CI/CD\", \"Docker\", \"README\" }\nlocal selectedFeatures = stdio.prompt(\"multiselect\", \"Features:\", features)\n\n-- Confirm\nprint()\nprint(bold .. \"Summary:\" .. stdio.style(\"reset\"))\nprint(\"  Name: \" .. name)\nprint(\"  Template: \" .. templates[templateIdx])\nif selectedFeatures then\n    local featureNames = {}\n    for _, i in selectedFeatures do\n        table.insert(featureNames, features[i])\n    end\n    print(\"  Features: \" .. table.concat(featureNames, \", \"))\nend\n\nlocal proceed = stdio.prompt(\"confirm\", \"Create project?\", true)\n\nif proceed then\n    fs.writeDir(name .. \"/src\")\n    fs.writeFile(name .. \"/src/main.luau\", \"print('Hello!')\\n\")\n    print(green .. \"\u2713 Project created!\" .. reset)\nelse\n    print(red .. \"Cancelled\" .. reset)\nend\n</code></pre>"},{"location":"guides/stdio/#complete-example-progress-spinner","title":"Complete Example: Progress Spinner","text":"<pre><code>local stdio = require(\"@lux/stdio\")\nlocal task = require(\"@lux/task\")\n\nlocal function withSpinner(message, fn)\n    local frames = { \"\u280b\", \"\u2819\", \"\u2839\", \"\u2838\", \"\u283c\", \"\u2834\", \"\u2826\", \"\u2827\", \"\u2807\", \"\u280f\" }\n    local done = false\n    local result\n\n    -- Spinner task\n    task.spawn(function()\n        local i = 1\n        while not done do\n            stdio.write(\"\\r\" .. frames[i] .. \" \" .. message)\n            i = (i % #frames) + 1\n            task.wait(0.08)\n        end\n    end)\n\n    -- Run the actual work\n    result = fn()\n    done = true\n\n    -- Clear spinner and show done\n    stdio.write(\"\\r\" .. stdio.color(\"green\") .. \"\u2713\" .. stdio.color(\"reset\") .. \" \" .. message .. \"\\n\")\n\n    return result\nend\n\n-- Usage\nwithSpinner(\"Loading data...\", function()\n    task.wait(2)  -- Simulate work\n    return \"done\"\nend)\n</code></pre>"}]}